[[traversal]]
The Traversal
=============

image::gremlin-running.png[width=125]

At the most general level there is `Traversal<S,E>` which implements `Iterator<E>`, where the `S` stands for start and the `E` stands for end. A traversal is composed of four primary components:
  
 . `Step<S,E>`: an individual function applied to `S` to yield `E`. Steps are chained within a traversal.
 . `TraversalStrategy`: interceptor methods to alter the execution of the traversal (i.e. query re-writing typically used only by vendors).
 . `TraversalSideEffects`: key/value pairs that can be used to store global information about the traversal.
 . `Traverser<T>`: the object propagating through the `Traversal` currently representing an object of type `T`. 

The classic notion of a graph traversal is provided by `GraphTraversal<S,E>` which extends `Traversal<S,E>`. GraphTraversal provides an interpretation of the graph data in terms of vertices, edges, etc. and thus, a graph traversal link:http://en.wikipedia.org/wiki/Domain-specific_language[DSL].

[[graph-traversal-steps]]
Graph Traversal Steps
---------------------

image::step-types.png[width=650]

A `GraphTraversal<S,E>` can be spawned off of a Graph, Vertex, Edge, or VertexProperty. It can also be spawned anonymously (i.e. empty) via `__`. A graph traversal is composed of an ordered list of steps. All the steps provided by `GraphTraversal` inherit from the more general forms diagrammed above. A list of all the steps (and their descriptions) are provided in the TinkerPop3 link:http://www.tinkerpop.com/javadocs/x.y.z/core/com/tinkerpop/gremlin/process/graph/GraphTraversal.html[GraphTraversal JavaDoc]. The following subsections will demonstrate the GraphTraversal steps using the <<gremlin-console,Gremlin Console>>.

[[lambda-steps]]
Lambda Steps
~~~~~~~~~~~~

There are four generic steps by which all other specific steps described later extend.

[width="100%",cols="10,12",options="header"]
|=========================================================
| Step| Description
| `map(Function<Traverser<S>, E>)` | map the traverser to some object of type `E` for the next step to process.
| `flatMap(Function<Traverser<S>, Iterator<E>>)` | map the traverser to an iterator of `E` objects that are streamed to the next step.
| `filter(Predicate<Traverser<S>>)` | map the traverser to either true or false, where false will not pass the traverser to the next step.
| `sideEffect(Consumer<Traverser<S>>)` | perform some operation on the traverser and pass it to the next step.
| `branch(Function<Traverser<S>,Collection<String>>)` | split the traverser to all the steps that have a label in the returned string collection.
|=========================================================

The `Traverser<S>` object provides access to:

 . The current traversed `S` object -- `Traverser.get()`.
 . The current path traversed by the traverser -- `Traverser.path()`.
  .. A helper shorthand to get a particular path-history object -- `Traverser.path(String) == Traverser.path().get(String)`.
 . The number of times the traverser has gone through the current loop -- `Traverser.loops()`.
 . The number of objects represented by this traverser -- `Traverser.bulk()`.
 . The local data structure associated with this traverser -- `Traverser.sack()`.
 . The side-effects associated with the traversal -- `Traverser.sideEffects()`.
  .. A helper shorthand to get a particular side-effect -- `Traverser.sideEffect(String) == Traverser.sideEffects().get(String)`.

IMPORTANT: If a specific traversal step can do the necessary step-computation, use it. Lambda steps can not be optimized by the Gremlin <<traversalstrategy,traversal strategies>> and should only be used when the requisite computation does not have a corresponding standard Gremlin step. For example, instead of `filter{it.get().property('name').isPresent()}` use `has('name')`.

image:map-lambda.png[width=150,float=right]
[source,groovy]
gremlin> g.V(1).as('a').out() <1>
==>v[3]
==>v[2]
==>v[4]
gremlin> g.V(1).as('a').out().map{it.path('a')} <2>
==>v[1]
==>v[1]
==>v[1]
gremlin> g.V(1).as('a').out().back('a') <3>
==>v[1]
==>v[1]
==>v[1]

<1> A standard outgoing traversal from vertex 1.
<2> For each vertex outgoing adjacent to vertex 1, get the vertex at `a` (which is vertex 1).
<3> The <<back-step,`back()`>>-step is implemented as a `map()`-step that accesses data in the historic path.

image:filter-lambda.png[width=160,float=right]
[source,groovy]
gremlin> g.V().filter{it.get().label() == 'person'} <1>
==>v[1]
==>v[2]
==>v[4]
==>v[6]
gremlin> g.V().has(label,'person') <2>
==>v[1]
==>v[2]
==>v[4]
==>v[6]

<1> A filter that only allows the vertex to pass if it has an age-property.
<2> The more specific `has()`-step is implemented as a `filter()` with respective predicate.


image:side-effect-lambda.png[width=175,float=right]
[source,groovy]
gremlin> g.V().has(label,'person').sideEffect{println it} <1>
v[1]
==>v[1]
v[2]
==>v[2]
v[4]
==>v[4]
v[6]
==>v[6]

<1> Whatever enters `sideEffect()` is passed to the next step, but some intervening process can occur.

image:branch-lambda.png[width=180,float=right]
[source,groovy]
gremlin> g.V().branch{it.get().value('name') == 'marko' ? ['a'] : ['b'] }.as('a').
                 values('age').branch{['c']}.as('b').
                 values('name').as('c') <1>
==>vadas
==>29
==>lop
==>josh
==>ripple
==>peter
gremlin> g.V().choose({it.value('name') == 'marko'},
                        __.values('age'),
                        __.values('name')) <2>
==>29
==>vadas
==>lop
==>josh
==>ripple
==>peter

<1> If the vertex is "marko", get his age, else get the name of the vertex.
<2> The more specific `choose()`-step is implemented as a `branch()`.

[[addedge-step]]
AddEdge Step
~~~~~~~~~~~~

image::addedge-step.png[width=450]

link:http://en.wikipedia.org/wiki/Automated_reasoning[Reasoning] is the process of making explicit in the data was is implicit in the data. What is explicit in a graph are the objects of the graph -- i.e. vertices and edges. What is implicit in the graph is the traversal. In other words, traversals expose meaning where the meaning is defined by the traversal description. For example, take the concept of a "co-developer." Two people are co-developers if they have worked on the same project together. This concept can be represented as a traversal and thus, the concept of "co-developers" can be derived. This is made possible with `addE()`-step (*sideEffect*).

[source,groovy]
gremlin> g.V(1).as('a').out('created')
==>v[3]
gremlin> g.V(1).as('a').out('created').in('created')
==>v[1]
==>v[4]
==>v[6]
gremlin> g.V(1).as('a').out('created').in('created').except('a') // marko can't be a co-developer with himself
==>v[4]
==>v[6]
gremlin> g.V(1).as('a').out('created').in('created').except('a').addBothE('co-developer','a')
==>v[4]
==>v[6]
gremlin> g.V(1).out('co-developer').values('name')
==>josh
==>peter
gremlin> g.V(1).out('co-developer').in('co-developer')
==>v[1]
==>v[1]

Note that it is possible to add an arbitrary number of key/value pairs (i.e. Object var args) to the `addE` steps to have those attached as properties to the created edges. 


[[aggregate-step]]
Aggregate Step
~~~~~~~~~~~~~~

image::aggregate-step.png[width=800]

The `aggregate()`-step (*sideEffect*) is used to aggregate all the objects at a particular point of traversal into a Collection. The step uses link:http://en.wikipedia.org/wiki/Eager_evaluation[eager evaluation] in that no objects continue on until all previous objects have been fully aggregated (as opposed to <<store-step,`store()`>> which link:http://en.wikipedia.org/wiki/Lazy_evaluation[lazily] fills a collection). The eager evaluation nature is crucial in situations where everything at a particular point is required for future computation. An example is provided below.

[source,groovy]
gremlin> g.V(1).out('created') // what has marko created?
==>v[3]
gremlin> g.V(1).out('created').aggregate('x') // aggregate all his creations
==>{v[3]}
gremlin> g.V(1).out('created').aggregate('x').in('created') // who are marko's collaborators
==>v[1]
==>v[4]
==>v[6]
gremlin> g.V(1).out('created').aggregate('x').in('created').out('created') // what have marko's collaborators created?
==>v[3]
==>v[5]
==>v[3]
==>v[3]
gremlin> g.V(1).out('created').aggregate('x').in('created').out('created').except('x').values('name') // what have marko's collaborators created that he hasn't created?
==>ripple

In link:http://en.wikipedia.org/wiki/Recommender_system[recommendation systems], the above pattern is used:
	
	"What has userA liked? Who else has liked those things? What have they liked that userA hasn't already liked?"

Finally, `aggregate()`-step can be modulated via `by()`-projection.

[source,groovy]
gremlin> g.V().out('knows').aggregate()
==>{v[2]=1, v[4]=1}
gremlin> g.V().out('knows').aggregate().by('name')
==>{vadas=1, josh=1}


[[back-step]]
Back Step
~~~~~~~~~

link:http://en.wikipedia.org/wiki/Functional_programming[Functional languages] make use of function composition and lazy evaluation to create complex computations from primitive operations. This is exactly what Gremlin `GraphTraversal` does. One of the differentiating aspects of Gremlin's data flow approach to graph processing is that the flow need not always go "forward," but in fact, can go back to a previously seen area of computation. Examples include <<repeat-step,`repeat()`>> as well as the `back()`-step (*map*).

[source,groovy]
gremlin> g.V().out().out()
==>v[5]
==>v[3]
gremlin> g.V().out().out().path()
==>[v[1], v[4], v[5]]
==>[v[1], v[4], v[3]]
gremlin> g.V().as('x').out().out().back('x')
==>v[1]
==>v[1]
gremlin> g.V().out().as('x').out().back('x')
==>v[4]
==>v[4]
gremlin> g.V().out().out().as('x').back('x') // pointless
==>v[5]
==>v[3]

[[between-step]]
Between Step
~~~~~~~~~~~~

The `between()`-step (*filter*) is similar to <<has-step,`has()`>>-step in that it filters elements according to their properties.

[source,groovy]
gremlin> g.V().between('age',20,30)
==>v[1]
==>v[2]
gremlin> g.V().between('age',20,30).values('age')
==>29
==>27
gremlin> g.V().has('age',gte,20).has('age',lt,30).values('age') // the equivalent expression using only has()
==>29
==>27

[[choose-step]]
Choose Step
~~~~~~~~~~~

The `choose()`-step (*branch*) allows for the current traverser to select which traversal branch to take. With `choose()`, it is possible to implement if/else-based semantics. The first set of examples below provide information about the vertices of the graph so its easier to understand the `choose()` examples to follow.

[source,groovy]
gremlin> g.V().has(label,'person').values('name').map{[it.get(), it.get().length()]}
==>[marko, 5]
==>[vadas, 5]
==>[josh, 4]
==>[peter, 5]
gremlin> g.V().has(label,'person').filter{it.get().value('name').length() == 5}.in().values('name')
==>marko
gremlin> g.V().has(label,'person').filter{it.get().value('name').length() == 4}.out().values('name')
==>ripple
==>lop

Given the facts above, the following examples show how to use `choose()` to select the values.

image::choose-step.png[width=700]

[source,groovy]
gremlin> g.V().has(label,'person').choose({it.value('name').length() == 5},   // If the predicate is true, then do `in`, else do `out`.
  __.in(),
  __.out()).values('name')
==>marko
==>ripple
==>lop
gremlin> g.V().has(label,'person').choose({it.value('name').length()},   // Use the result of the function as a key to the map of traversal choices.
  [5:__.in(),
   4:__.out()]).values('name')
==>marko
==>ripple
==>lop

In Java8, there is no elegant syntax to create a `Map`. Thus, the last traversal above would look as follows:

[source,java]
g.V().has("age").choose(v -> v.value("name").length(), new HashMap() {{
  put(5,__.in());
  put(4,__.out());
}}).values("name")

[[coin-step]]
Coin Step
~~~~~~~~~

To randomly filter out a traverser, use the `coin()`-step (*filter*). The provided double argument biases the "coin toss."

[source,groovy]
gremlin> g.V().coin(0.5)
==>v[2]
==>v[3]
gremlin> g.V().coin(0.0)
gremlin> g.V().coin(1.0)
==>v[1]
==>v[2]
==>v[3]
==>v[4]
==>v[5]
==>v[6]

[[cyclicpath-step]]
CyclicPath Step
~~~~~~~~~~~~~~~

image::cyclicpath-step.png[width=400]

Each traverser maintains its history through the traversal over the graph -- i.e. its <<path-data-structure,path>>. If it is important that the traverser repeat its course, then `cyclic()`-path should be used (*filter*). The step analyzes the path of the traverser thus far and if there are any repeats, the traverser is filtered out over the traversal computation. If non-cyclic behavior is desired, see <<simplepath-step,`simplePath()`>>.

[source,groovy]
gremlin> g.V(1).both().both()
==>v[1]  // back to v[1]
==>v[4]
==>v[6]
==>v[1]  // back to v[1]
==>v[5]
==>v[3]
==>v[1]  // back to v[1]
gremlin> g.V(1).both().both().cyclicPath()
==>v[1]
==>v[1]
==>v[1]
gremlin> g.V(1).both().both().cyclicPath().path()
==>[v[1], v[3], v[1]]
==>[v[1], v[2], v[1]]
==>[v[1], v[4], v[1]]

[[dedup-step]]
Dedup Step
~~~~~~~~~~

With `dedup()`-step (*filter*), repeatedly seen objects are removed from the traversal stream. Note that if a traverser's bulk is greater than 1, then it is set to 1 before being emitted.

[source,groovy]
gremlin> g.V().values('lang')
==>java
==>java
gremlin> g.V().values('lang').dedup()
==>java

If a lambda is provided to `dedup()`, then the object is processed by the lambda prior to determining if it has been seen or not.

[source,groovy]
gremlin> g.V().values('name').map{[it.get(), it.get().length()]}
==>[marko, 5]
==>[vadas, 5]
==>[lop, 3]
==>[josh, 4]
==>[ripple, 6]
==>[peter, 5]
gremlin> g.V().values('name').dedup().by{it.length()}
==>marko
==>lop
==>josh
==>ripple

WARNING: The `dedup()`-step does not have a correlate in <<traversalvertexprogram,Gremlin OLAP>> when used mid-traversal. When in mid-traversal de-duplication only occurs at the the current processing vertex and thus, is not a global operation as it in Gremlin OLTP. When `dedup()` is an end step, the resultant traversers are de-duplicated by `TraverserMapReduce`.

[[except-step]]
Except Step
~~~~~~~~~~~

The `except()`-step (*filter*) can be used to remove objects from the traversal stream. If `except()` is provided a string, then the excepting object is located at `traverser.sideEffects().get(label)`. If `except()` is provided a collection, then any object contained in that collection is filtered out. Please see the related <<retain-step,`retain()`>>-step.

[source,groovy]
gremlin> g.V(1).as('x').out('created').in('created')
==>v[1]
==>v[4]
==>v[6]
gremlin> g.V(1).as('x').out('created').in('created').except('x') // co-developers
==>v[4]
==>v[6]
gremlin> g.V(1).as('x').out('created').in('created').values('name')
==>marko
==>josh
==>peter
gremlin> g.V(1).as('x').out('created').in('created').values('name').except(['marko','stephen'])
==>josh
==>peter

[[fold-step]]
Fold Step
~~~~~~~~~

There are situations when the traversal stream needs a "barrier" to aggregate all the objects and emit a computation that is a function of the aggregate. The `fold()`-step (*map*) is one particular instance of this. Please see <<unfold-step,`unfold()`>>-step for the inverse functionality.

[source,groovy]
gremlin> g.V(1).out('knows').values('name')
==>vadas
==>josh
gremlin> g.V(1).out('knows').values('name').fold() <1>
==>[vadas, josh]
gremlin> g.V(1).out('knows').values('name').fold().next().getClass() <2>
==>class java.util.ArrayList
gremlin> g.V(1).out('knows').values('name').fold(0){a,b -> a + b.length()} <3>
==>9
gremlin> g.V().values('age').fold(0){a,b -> a + b} <4>
==>123

<1> A parameterless `fold()` will aggregate all the objects into a list and then emit the list.
<2> A verification of the type of list returned.
<3> `fold()` can be provided two arguments --  a seed value and a reduce bi-function ("vadas" is 5 characters + "josh" with 4 characters).
<4> What is the total age of the people in the graph?

[[group-step]]
Group Step
~~~~~~~~~~

As traversers propagate across a graph as defined by a traversal, sideEffect computations are sometimes required. That is, the actually path taken or the current location of a traverser is not the ultimate output of the computation, but some other representation of the traversal. The `group()`-step (*sideEffect*) is one such sideEffect that organizes the objects according to some function of the object. Then, if required, that organization (a list) is reduced. An example is provided below.

[source,groovy]
gremlin> g.V().group().by{it.value('name')[1]}   // group the vertices by the second letter of their name
==>[a:[v[1], v[2]], e:[v[6]], i:[v[5]], o:[v[3], v[4]]]
gremlin> g.V().group().by{it.value('name')[1]}.by{it.value('name')}   // for each vertex in the group, get their name (now the name[1] is apparent)
==>[a:[marko, vadas], e:[peter], i:[ripple], o:[lop, josh]]
gremlin> g.V().group().by{it.value('name')[1]}.by{it.value('name')}.by{it.size()}   // for each grouping, what is it's size?
==>[a:2, e:1, i:1, o:2]

The three projection parameters available to `group()` via `by()` are:

. Key-projection: What feature of the object to group on (a function that yields the map key)?
. Value-projection: What feature of the group to store in the key-list?
. Reduce-projection: What feature of the key-list to ultimately return?

WARNING: The `group()`-step does not have a correlate in <<traversalvertexprogram,Gremlin OLAP>> when used mid-traversal. When in mid-traversal grouping only occurs at the the current processing vertex and thus, is not a global operation as it in Gremlin OLTP. However, `GroupMapReduce` provides unified groups at the end of the traversal computation.

[[groupcount-step]]
GroupCount Step
~~~~~~~~~~~~~~~

When it is important to know how many times a particular object has been at a particular part of a traversal, `groupCount()`-step (*sideEffect*) is used.

	"What is the distribution of ages in the graph?"

[source,groovy]
gremlin> g.V().has(label,'person').values('age').groupCount()
==>[32:1, 35:1, 27:1, 29:1]
gremlin> g.V().has(label,'person').groupCount().by('age') // you can also supply a pre-group projection
==>[32:1, 35:1, 27:1, 29:1]

There is one person that is 32, one person that is 35, one person that is 27, and one person that is 29.

	"Iteratively walk the graph and count the number of times you see the second letter of each name."

image::groupcount-step.png[width=420]

[source,groovy]
gremlin> g.V().repeat(__.both().groupCount('m').by{it.value('name')[1]}).times(10).cap('m')
==>[a:19598, e:5740, i:5740, o:27716]

The above is interesting in that it demonstrates the use of referencing the internal `Map<Object,Long>` of `groupCount()` with a string variable. Given that `groupCount()` is a sideEffect-step, it simply passes the object it received to its output. Internal to `groupCount()`, the object's count is incremented. If `groupCount()` is the last step in the traversal, the `SideEffectCapStrategy` (see <<traversalstrategy,Traversal Strategy>>) automatically returns the internal map. However, if the `groupCount()` is not the last step, then the sideEffect data structure (i.e. the internal map of `groupCount()`) can be accessed with `cap()`-step by referencing the desired variable.

WARNING: The `groupCount()`-step does not have a correlate in <<traversalvertexprogram,Gremlin OLAP>> when used mid-traversal. When in mid-traversal grouping only occurs at the the current processing vertex and thus, is not a global operation as it in Gremlin OLTP. However, `GroupCountMapReduce` provides unified groups at the end of the traversal computation.

[[has-step]]
Has Step
~~~~~~~~

image::has-step.png[width=670]

It is possible to filter vertices, edges, and vertex properties based on their properties using `has()`-step (*filter*).

[source,groovy]
gremlin> g.V().has(label,'person')
==>v[1]
==>v[2]
==>v[4]
==>v[6]
gremlin> g.V().has(label,'person').out().has('name',within,['vadas','josh'])
==>v[2]
==>v[4]
gremlin> g.V().has(label,'person').out().has('name',within,['vadas','josh']).outE().has(label,'created') // label is a "token" from T
==>e[10][4-created->5]
==>e[11][4-created->3]

There are accessors available in the `T` "tokens" class. They include `label`, `id`, `key`, and `value`. Thus, it is possible to use `has()`-step to also filter on these aspects of an element.

[[inject-step]]
Inject Step
~~~~~~~~~~~

image::inject-step.png[width=800]

One of the major features of TinkerPop3 is "injectable steps." This makes it possible to insert objects arbitrarily into a traversal stream. In general, `inject()`-step (*sideEffect*) exists and a few examples are provided below.

[source,groovy]
gremlin> g.V(4).out().values('name').inject('daniel')
==>daniel
==>ripple
==>lop
gremlin> g.V(4).out().values('name').inject('daniel').map{it.get().length()}
==>6
==>6
==>3
gremlin> g.V(4).out().values('name').inject('daniel').map{it.get().length()}.path()
==>[daniel, 6]
==>[v[4], v[5], ripple, 6]
==>[v[4], v[3], lop, 3]

In the last example above, note that the path starting with `daniel` is only of length 2. This is because the `daniel` string was inserted half-way in the traversal. Finally, a typical use case is provided below -- when the start of the traversal is not a graph object.

[source,groovy]
gremlin> __.inject(1,2)
==>1
==>2
gremlin> __.inject(1,2).map{it.get() + 1}
==>2
==>3
gremlin> __.inject(1,2).map{it.get() + 1}.map{g.V(it.get()).next()}.values('name')
==>vadas
==>lop

[[limit-step]]
Limit Step
~~~~~~~~~~

The `limit()`-step is analogous to <<range-step,`range()`-step>> save that the lower end range is set to 0.

[source,groovy]
gremlin> g.V().limit(2)
==>v[1]
==>v[2]
gremlin> g.V().range(0,2)
==>v[1]
==>v[2]
gremlin> g.V().limit(2).toString()
==>[TinkerGraphStep(vertex), RangeStep(0,2)]

[[local-step]]
Local Step
~~~~~~~~~~

image::local-step.png[width=450]

A `GraphTraversal` operates on a continuous stream of objects. In many situations, it is important to operate on a single element within that stream. To do such object-local traversal computations, `local()`-step exists (*map*). Note that the examples below use the <<the-crew-toy-graph,The Crew>> toy data set.

[source,groovy]
gremlin> g = TinkerFactory.createTheCrew()
==>tinkergraph[vertices:6 edges:14]
gremlin> g.V().as('person').
           properties('location').order().by('startTime',incr).limit(2).
           value().as('location').select().by('name').by{it} <1>
==>[person:daniel, location:spremberg]
==>[person:stephen, location:centreville]
gremlin> g.V().as('person').
           local(__.properties('location').order().by('startTime',incr).limit(2)).
           value().as('location').select().by('name').by{it} <2>
==>[person:marko, location:san diego]
==>[person:marko, location:santa cruz]
==>[person:stephen, location:centreville]
==>[person:stephen, location:dulles]
==>[person:matthias, location:bremen]
==>[person:matthias, location:baltimore]
==>[person:daniel, location:spremberg]
==>[person:daniel, location:kaiserslautern]

<1> Get the first two people and their respective location according to the most historic location start time.
<2> For every person, get their two most historic locations.

The two traversals above look nearly identical save the inclusion of `local()` which wraps a section of the traversal in a object-local traversal. As such, the `orderBy()` and the `limit()` refer to a particular object, not to the stream as a whole.

[[match-step]]
Match Step
~~~~~~~~~~

The `match()`-step (*map*) is introduced into TinkerPop3 to support a more link:http://en.wikipedia.org/wiki/Declarative_programming[declarative] form of link:http://en.wikipedia.org/wiki/Pattern_matching[pattern matching]. Similar constructs were available in previous TinkerPop versions via the `table()`-step, but that has since been removed in favor of the `match().select()`-pattern. With MatchStep in TinkerPop, a query optimizer similar to the link:http://www.knowledgefrominformation.com/2011/04/16/budget-match-cost-effective-subgraph-matching-on-large-networks/[budget match algorithm] builds and revises query plans on the fly, while a query is in progress. For very large graphs, where the developer is uncertain of the statistics of the graph (e.g. how many `knows`-edges vs. `worksFor`-edges exist in the graph), it is advantageous to use `match()`, as an optimal plan will be determined automatically.  Furthermore, some queries are much easier to express via `match()` than with single-path traversals.

	"Who created a project named 'lop' that was also created by someone who is 29 years old? Return the two creators."

image::match-step.png[width=500]

[source,groovy]
gremlin> g.V().match('a',
            __.as('a').out('created').as('b'),
            __.as('b').has('name', 'lop'),
            __.as('b').in('created').as('c'),
            __.as('c').has('age', 29)).
          select('a', 'c').by('name')
==>[a:marko, c:marko]
==>[a:josh, c:marko]
==>[a:peter, c:marko]

Note that the above can also be more concisely written as below which demonstrates that imperative inner-traversals can be arbitrarily defined.

[source,groovy]
gremlin> g.V().match('a',
            __.as('a').out('created').has('name', 'lop').as('b'),
            __.as('b').in('created').has('age', 29).as('c')).
          select('a','c').by('name')
==>[a:marko, c:marko]
==>[a:josh, c:marko]
==>[a:peter, c:marko]


MatchStep brings functionality similar to link:http://en.wikipedia.org/wiki/SPARQL[SPARQL] to Gremlin. Like SPARQL, MatchStep conjoins a set of patterns applied to a graph.  For example, the following traversal finds exactly those songs which Jerry Garcia has both sung and written (using the Grateful Dead graph distributed in the `data/` directory):  

[source,groovy]
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> g.io().readGraphML('data/grateful-dead.xml')
==>null
gremlin> g.V().match('a',
            __.as('a').has('name', 'Garcia'),
            __.as('a').in('writtenBy').as('b'),
            __.as('a').in('sungBy').as('b')).select('b').values('name')
==>CREAM PUFF WAR
==>CRYPTICAL ENVELOPMENT

Among the features which differentiate `match()` from SPARQL are:

[source,groovy]
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().match('a',
            __.as('a').out('created').has('name','lop').as('b'), <1>
            __.as('b').in('created').has('age', 29).as('c'),
            __.as('c').repeat(__.out()).times(2)). <2>
           select('c').out('knows').dedup().values('name') <3>
==>vadas
==>josh

<1> *Patterns of arbitrary complexity*: `match()` is not restricted to triple patterns or property paths.
<2> *Recursion support*: `match()` supports the branch-based steps within a pattern, including `repeat()`.
<3> *Imperative/declarative hybrid*: Pre and prior to a `match()`, it is possible to leverage classic Gremlin imperative.

To extend point #3, it is possible to support going from imperative, to declarative, to imperative, ad infinitum.

[source,groovy]
gremlin> g.V().match('a',
            __.as('a').out('knows').as('b'),
            __.as('b').out('created').has('name','lop')).
          select('b').
          out('created').
          match('a',
            __.as('a').in('created').as('b'),
            __.as('b').out('knows').as('c')).
          select('c').values('name')
==>vadas
==>josh

Like all other steps in Gremlin, `match()` is a function and thus, `match()` within `match()` is a natural consequence of Gremlin's functional foundation (i.e. recursive matching).

[source,groovy]
gremlin> g.V().match('a',
            __.as('a').out('knows').as('b'),
            __.as('b').out('created').has('name','lop'),
            __.as('b').match('x',
                __.as('x').out('created').as('y'),
                __.as('y').has('name','ripple')).select('y').as('c')).
            select('a','c').by('name')
==>[a:marko, c:ripple]

WARNING: Currently, `match()` does not operate within a multi-JVM <<graphcomputer,GraphComputer>> OLAP environment. Future work includes a linearization <<traversalstrategy,TraversalStrategy>> for `match()`.

[[using-where-with-match]]
Using Where with Match
^^^^^^^^^^^^^^^^^^^^^^

Match is typically used in conjunction with both `select()` (demonstrated previously) and `where()` (presented here). A `where()` allows the user to further constrain the result set provided by `match()`.

[source,groovy]
gremlin> g.V().match('a',
            __.as('a').out('created').as('b'),
            __.as('b').in('created').as('c')).
              where('a', neq, 'c').
               select('a','c').by('name')
==>[a:marko, c:josh]
==>[a:marko, c:peter]
==>[a:josh, c:marko]
==>[a:josh, c:peter]
==>[a:peter, c:marko]
==>[a:peter, c:josh]

The `where()`-step can take either a `BiPredicate` (first example below) or a `Traversal` (second example below). Using `MatchWhereStrategy`, `where()`-clauses can be automatically folded into `match()` and thus, subject to `match()`-steps budget-match algorithm.

[source,groovy]
gremlin> traversal = g.V().match('a',
            __.as('a').out('created').as('b'),
            __.as('b').in('created').as('c')).
              where(__.as('a').out('knows').as('c')). <1>
               select('a','c').by('name'); null <2>
==>null
gremlin> traversal.toString()
==>[TinkerGraphStep(vertex), MatchStep, WhereStep, SelectStep([a, c])] <3>
gremlin> traversal <4>
==>[a:marko, c:josh] <5>
gremlin> traversal.toString()
==>[TinkerGraphStep(vertex), MatchStep, SelectStep([a, c])] <6>

<1> A `where()`-step with a traversal containing variable bindings declared in `match()`.
<2> A useful trick to ensure that that the traversal is not iterated by Gremlin Console.
<3> The string representation of the traversal prior to its strategies being applied.
<4> The Gremlin Console will automatically iterate anything that is an iterator or is iterable.
<5> Both marko and josh are co-developers and marko knows josh.
<6> The string representation of the traversal after the strategies have been applied (and thus, `where()` is folded into `match()`)

[[order-step]]
Order Step
~~~~~~~~~~

When the objects of the traversal stream need to be sorted, `order()`-step (*map*) can be leveraged.

[source,groovy]
gremlin> g.V().values('name').order()
==>josh
==>lop
==>marko
==>peter
==>ripple
==>vadas
gremlin> g.V().values('name').order(decr)
==>vadas
==>ripple
==>peter
==>marko
==>lop
==>josh
gremlin> g.V().values('name').order().by{a,b -> a[1] <=> b[1]}
==>marko
==>vadas
==>peter
==>ripple
==>lop
==>josh

Note that `order()` takes a `Comparator` var args and thus, its possible to do secondary sorting. Secondary sorting is presented below along with the handy `Comparator.comparing()` method.

[source,groovy]
gremlin> import static java.util.Comparator.*
...
gremlin> g.V().values('name').order().by(comparing{it[1]}) // order by the second letter
==>marko
==>vadas
==>peter
==>ripple
==>lop
==>josh
gremlin> g.V().values('name').order().by(comparing{it[1]}).by(comparing{it[2]}) // order by second letter and if a tie, the third letter
==>vadas
==>marko
==>peter
==>ripple
==>lop
==>josh

One of the most traversed objects in a traversal is an `Element`. An element can have properties associated with it (i.e. key/value pairs). In many situations, it is desirable to sort an element traversal stream according to a comparison of their properties.

[source,groovy]
gremlin> g.V().values('name')
==>marko
==>vadas
==>lop
==>josh
==>ripple
==>peter
gremlin> g.V().order().by('name',incr).values('name')
==>josh
==>lop
==>marko
==>peter
==>ripple
==>vadas
gremlin> g.V().order().by('name',decr).values('name')
==>vadas
==>ripple
==>peter
==>marko
==>lop
==>josh

The `order()`-step allows the user to provide an arbitrary number of comparators for primary, secondary, etc. sorting. These comparators can be lambdas or they can be pre-defined enums (e.g. `Order.incr`). It is always best to use a pre-defined enum instead of a generic lambda as the underlying vendor may be able to optimize the execution when the comparator is inspectable.

[source,groovy]
gremlin> g.V().has(label,'person').order().by('name'){a,b->a[1] <=> b[1]}.by('age',incr).values('name')
==>vadas
==>marko
==>peter
==>josh
gremlin> g.V().has(label,'person').order().by('name'){a,b->a[1] <=> b[1]}.by('age',decr).values('name')
==>marko
==>vadas
==>peter
==>josh

[[path-step]]
Path Step
~~~~~~~~~

A traverser is transformed as it moves through a series of steps within a traversal. The history of the traverser is realized by examining its path with `path()`-step (*map*).

image::path-step.png[width=650]

[source,groovy]
gremlin> g.V().out().out().values('name')
==>ripple
==>lop
gremlin> g.V().out().out().values('name').path()
==>[v[1], v[4], v[5], ripple]
==>[v[1], v[4], v[3], lop]

If edges are required in the path, then be sure to traverser those edges explicitly.

[source,groovy]
gremlin> g.V().outE().inV().outE().inV().path()
==>[v[1], e[8][1-knows->4], v[4], e[10][4-created->5], v[5]]
==>[v[1], e[8][1-knows->4], v[4], e[11][4-created->3], v[3]]

It is possible to post-process the elements of the path in a round-robin fashion via `by()`.

[source,groovy]
gremlin> g.V().out().out().path().by('name').by('age')
==>[marko, 32, ripple]
==>[marko, 32, lop]

Finally, because `by()`-based post-processing, nothing prevents triggering yet another traversal. In the traversal below, for each element of the path traversed thus far, if its a person (as determined by having an `age`-property), then get all of their creations, else if its a creation, get all the people that created it.

[source,groovy]
gremlin> g.V().out().out().path().by{
  it.choose({it.has(label,'person').hasNext()},
    __.out('created').values('name'),
    __.in('created').values('name')).toList()}
==>[[lop], [ripple, lop], [josh]]
==>[[lop], [ripple, lop], [marko, josh, peter]]

WARNING: Generating path information is expensive as the history of the traverser is stored into a Java list. With numerous traversers, there are numerous lists. Moreover, in an OLAP <<graphcomputer,`GraphComputer`>> environment this becomes exceedingly prohibitive as there are traversers emanating from all vertices in the graph in parallel. In OLAP there are optimizations provided for traverser populations, but when paths are calculated (and each traverser is unique due to its history), then these optimizations are no longer possible.

[[path-data-structure]]
Path Data Structure
^^^^^^^^^^^^^^^^^^^

The `Path` data structure is an ordered list of objects, where each object is associated to a `Set<String>` of labels. An example is presented below to demonstrate both the `Path` API as well as how a traversal yields labeled paths.

image::path-data-structure.png[width=350]

[source,groovy]
gremlin> path = g.V(1).as('a').has('name').as('b').out('knows').out('created').as('c').has('name','ripple').values('name').as('d').identity().as('e').path().next()
==>[v[1], v[4], v[5], ripple]
gremlin> path.size()
==>4
gremlin> path.objects()
==>v[1]
==>v[4]
==>v[5]
==>ripple
gremlin> path.labels()
==>[a, b]
==>[]
==>[c]
==>[d, e]
gremlin> path.a
==>v[1]
gremlin> path.b
==>v[1]
gremlin> path.c
==>v[5]
gremlin> path.d == path.e
==>true

[[profile-step]]
Profile Step
~~~~~~~~~~~~

The `profile()`-step (*sideEffect*) exists to allow developers to profile their traversals to determine statistical information like step runtime, counts, etc. The `profile()`-step can only be used if the system property `tinkerpop.profiling` is set to `true`. Thus, prior to starting the Gremlin Console, set `JAVA_OPTIONS` accordingly.

WARNING: When profiling is enabled, traversals are more costly to execute. Thus, be sure to not have `tinkerpop.profiling` set to `true` in any production or query time critical application. The best way to determine if profiling is enabled is to see if an `IllegalArgumentException` is thrown when the `profile()` step is used. If there is no exception, then profiling is enabled.

[source,groovy]
----
$ JAVA_OPTIONS=-Dtinkerpop.profiling=true bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.tinkergraph
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().out().out().profile()
==>Traversal Metrics
                            Step       Count Traversers       Time (ms)   % Dur
         TinkerGraphStep(vertex)           6          6           0.020    1.62
          VertexStep(OUT,vertex)           6          6           1.165   94.10
          VertexStep(OUT,vertex)           2          2           0.032    2.58
                     ProfileStep           2          2           0.004    0.32
               SideEffectCapStep           1          1           0.017    1.37
                           TOTAL           -          -           1.238       -
gremlin>
----

The `profile()`-step generates a `TraversalMetrics` object that contains the following information:

* `Step`: A step within the traversal being profiled.
* `Count`: The number of _represented_ traversers that passed through the step.
* `Traversers`: The number of traversers that passed through the step.
* `Time (ms)`: The total time the step was actively executing its behavior.
* `% Dur`: The percentage of total time spent in the step.

image:gremlin-exercise.png[width=120,float=left] It is important to understand the difference between `Count` and `Traversers`. Traversers can be merged and as such, when two traversers are "the same" they may be aggregated into a single traverser. That new traverser has a `Traverser.bulk()` that is the sum of the two merged traverser bulks. On the other hand, the `Count` represents the sum of all `Traverser.bulk()` results and thus, expresses the number of "represented" (not enumerated) traversers. `Traversers` will always be less than or equal to `Count`.

If `-Dtinkerpop.profiling=true` is not set, then the following exception occurs.

[source,groovy]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.tinkergraph
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().out().out().profile()
The profile()-step can only be used when profiling is enabled via 'gremlin.sh -p' or directly via -Dtinkerpop.profiling=true
Display stack trace? [yN]
gremlin>
----

TIP: It is possible to enabled profiling for a Gremlin Console session via `gremlin.sh -p`.

[[range-step]]
Range Step
~~~~~~~~~~

As traversers propagate through the traversal, it is possible to only allow a certain number of them to pass through with `range()`-step (*filter*). When the low-end of the range is not met, objects are continued to be iterated. When within the low and high range (both inclusive), traversers are emitted. Finally, when above the high range, the traversal breaks out of iteration.

[source,groovy]
gremlin> g.V().range(0,3)
==>v[1]
==>v[2]
==>v[3]
gremlin> g.V().range(1,3)
==>v[2]
==>v[3]
gremlin> g.V().repeat(__.both()).times(1000000).emit().range(6,10)
==>v[1]
==>v[5]
==>v[3]
==>v[1]

[[repeat-step]]
Repeat Step
~~~~~~~~~~~

image::gremlin-fade.png[width=350]

The `repeat()`-step (*branch*) is used for looping over a traversal given some break predicate. Below are some examples of `repeat()`-step in action.

[source,groovy]
gremlin> g.V(1).repeat(__.out()).times(2).path().by('name') <1>
==>[marko, josh, ripple]
==>[marko, josh, lop]
gremlin> g.V().until(__.has('name','ripple')).
                 repeat(__.out()).path().by('name') <2>
==>[marko, josh, ripple]
==>[josh, ripple]
==>[ripple]

<1> do-while semantics stating to do `out()` 2 times.
<2> while-do semantics stating to break if the traverser is at a vertex named "ripple".

IMPORTANT: There are two modulators for `repeat()`: `until()` and `emit()`. If `until()` comes after `repeat()` it is do/while looping. If `until()` comes before `repeat()` it is while/do looping. If `emit()` is placed after `repeat()`, it is evaluated on the traversers leaving the repeat-traversal. If `emit()` is placed before `repeat()`, it is evaluated on the traversers prior to entering the repeat-traversal.

NOTE: The `times(x)` step modulator is an alias for `until{it.loops() >= x}`.

The `repeat()`-step also supports an "emit predicate", where the predicate for an empty argument `emit()` is true (i.e. `emit() == emit{true}`). With `emit()`, the traverser is split in two -- the traverser exits the code block as well as continues back within the code block (assuming `until()` holds true).

[source,groovy]
gremlin> g.V(1).repeat(__.out()).times(2).emit().path().by('name') <1>
==>[marko, lop]
==>[marko, vadas]
==>[marko, josh]
==>[marko, josh, ripple]
==>[marko, josh, lop]
gremlin> g.V(1).emit().repeat(__.out()).times(2).path().by('name') <2>
==>[marko]
==>[marko, lop]
==>[marko, vadas]
==>[marko, josh]
==>[marko, josh, ripple]
==>[marko, josh, lop]

<1> The `emit()` comes after `repeat()` and thus, emission happens after the `repeat()` traversal is executed. Thus, no one vertex paths exist.
<2> The `emit()` comes before `repeat()` and thus, emission happens prior to the `repeat()` traversal being executed. Thus, one vertex paths exist.

The `emit()`-modulator can take an arbitrary predicate.

[source,groovy]
gremlin> g.V(1).repeat(__.out()).
                  times(2).
                  emit{it.get().property('lang').isPresent()}.path().by('name')
==>[marko, lop]
==>[marko, josh, ripple]
==>[marko, josh, lop]
gremlin> g.V(1).repeat(__.out()).
                  times(2).
                  emit(__.has('lang')).path().by('name') // the same query, but using a traversal instead of a predicate
==>[marko, lop]
==>[marko, josh, ripple]
==>[marko, josh, lop]

image::repeat-step.png[width=500]

[source,groovy]
gremlin> g.V(1).repeat(__.out()).times(2).emit().path().by('name')
==>[marko, lop]
==>[marko, vadas]
==>[marko, josh]
==>[marko, josh, ripple]
==>[marko, josh, lop]

The first time through the `repeat()`, the vertices lop, vadas, and josh are seen. Given that `loops==0`, the traverser repeats. However, because the emit-predicate is declared true, those vertices are emitted. At step 2 (`loops==1`), the vertices traversed are ripple and lop (Josh's created projects, as lop and vadas have no out edges) and are also emitted. Now `loops==1` so the traverser repeats. As ripple and lop have no out edges there are no vertices to traverse. Given that `loops==2`, the until-predicate fails. Therefore, the traverser has seen the vertices: lop, vadas, josh, ripple, and lop.

Finally, note that both `emit()` and `until()` can take a traversal and in such, situations, the predicate is determined by `traversal.hasNext()`. A few examples are provided below.

[source,groovy]
gremlin> g.V(1).repeat(__.out()).until(__.has(label,'software')).path().by('name') <1>
==>[marko, lop]
==>[marko, josh, ripple]
==>[marko, josh, lop]
gremlin> g.V(1).emit(__.has(label,'person')).repeat(__.out()).path().by('name') <2>
==>[marko]
==>[marko, vadas]
==>[marko, josh]
gremlin> g.V(1).repeat(__.out()).until(__.outE().count().cap().filter{it.get() == 0}).path().by('name') <3>
==>[marko, lop]
==>[marko, vadas]
==>[marko, josh, ripple]
==>[marko, josh, lop]
gremlin> g.V(1).repeat(__.out()).until{!it.get().outE().hasNext()}.path().by('name') <4>
==>[marko, lop]
==>[marko, vadas]
==>[marko, josh, ripple]
==>[marko, josh, lop]


<1> Starting from vertex 1, keep taking outgoing edges until a software vertex is reached.
<2> Starting from vertex 1, and in an infinite loop, emit the vertex if it is a person and then traverser the outgoing edges.
<3> Starting from vertex 1, keep taking outgoing edges until a vertex is reached that has no more outgoing edges.
<4> The same as <3>, but using a predicate argument for `until()`.

[[retain-step]]
Retain Step
~~~~~~~~~~~

The `retain()`-step (*filter*) can be used to filter objects from the traversal stream that don't match the provided criteria. If `retain()` is provided a string, the retaining object is retrieved via `traverser.path().get(label)`. If `retain()` is provided a collection, then any object not contained in that collection is filtered out. Please see the related <<except-step,`except()`>>-step.

[source,groovy]
gremlin> g.V(1).as('x').out('created').in('created')
==>v[1]
==>v[4]
==>v[6]
gremlin> g.V(1).as('x').out('created').in('created').retain('x')
==>v[1]
gremlin> g.V(1).as('x').out('created').in('created').values('name')
==>marko
==>josh
==>peter
gremlin> g.V(1).as('x').out('created').in('created').values('name').retain(['marko','stephen'])
==>marko

[[sack-step]]
Sack Step
~~~~~~~~~

image:gremlin-sacks-running.png[width=175,float=right] A traverser can contain a local data structure called a "sack". The `sack()`-step is used to read and write sacks (*sideEffect* or *map*). Each sack of each traverser is created when using `GraphTraversal.withSack(initialValueSupplier,splitOperator?)`.

* *Initial value supplier*: A `Supplier` providing the initial value of each traverser's sack.
* *Split operator*: a `UnaryOperator` that clones the traverser's sack when the traverser splits. If no split operator is provided, then `UnaryOperator.identity()` is assumed.

Two trivial examples are presented below to demonstrate the *initial value supplier*. In the first example below, a traverser is created at each vertex in the graph (`g.V()`), with a 1.0 sack (`withSack{1.0f}`), and then the sack value is accessed (`sack()`). In the second example, a random float supplier is used to generate sack values.

[source,groovy]
gremlin> g.V().withSack{1.0f}.sack()
==>1.0
==>1.0
==>1.0
==>1.0
==>1.0
==>1.0
gremlin> rand = new Random()
==>java.util.Random@12a160c2
gremlin> g.V().withSack{rand.nextFloat()}.sack()
==>0.20819736
==>0.39894062
==>0.1775086
==>0.85114276
==>0.8067685
==>0.21980786

A more complicated initial value supplier example is presented below where the sack values are used in a running computation and then emitted at the end of the traversal. When an edge is traversed, the edge weight is multiplied by the sack value (`sack(mult,'weight')`).

[source,groovy]
gremlin> g.V().withSack{1.0f}.repeat(__.outE().sack(mult,'weight').inV()).times(2)
==>v[5]
==>v[3]
gremlin> g.V().withSack{1.0f}.repeat(__.outE().sack(mult,'weight').inV()).times(2).sack()
==>1.0
==>0.4
gremlin> g.V().withSack{1.0f}.repeat(__.outE().sack(mult,'weight').inV()).times(2).path().by{it}.by('weight')
==>[v[1], 1.0, v[4], 1.0, v[5]]   // 1.0 * 1.0 * 1.0 = 1.0
==>[v[1], 1.0, v[4], 0.4, v[3]]   // 1.0 * 1.0 * 0.4 = 0.4

image:gremlin-sacks-standing.png[width=100,float=left] When complex objects are used (i.e. non-primitives), then a *split operator* should be defined to ensure that each traverser gets a clone of its parent's sack. The first example does not use a split operator and as such, the same map is propagated to all traversers (a global data structure). The second example, demonstrates how `Map.clone()` ensures that each traverser's sack contains a unique, local sack.

[source,groovy]
gremlin> g.V().withSack { [:] }.
           out().out().
           sack { m, v -> m[v.value('name')] = v.value('lang'); m }.sack() // BAD: single map
==>[ripple:java]
==>[ripple:java, lop:java]
gremlin> g.V().withSack { [:] } { m -> m.clone() }.
           out().out().
           sack { m, v -> m[v.value('name')] = v.value('lang'); m }.sack() // GOOD: cloned map
==>[ripple:java]
==>[lop:java]

NOTE: For primitives (i.e. integers, longs, floats, etc.), a split operator is not required as a primitives are encoded in the memory address of the sack, not as a reference to an object.

[[sample-step]]
Sample Step
~~~~~~~~~~~

The `sample()`-step is useful for sampling some number of traversers previous in the traversal.

[source,groovy]
gremlin> g.V().outE().sample(1).values('weight')
==>0.4
gremlin> g.V().outE().sample(1).by('weight').values('weight')
==>1.0
gremlin> g.V().outE().sample(2).by('weight').values('weight')
==>0.5
==>1.0

One of the more interesting use cases for `sample()` is when it is used in conjunction with <<local-step,`local()`>>. The combination of the two steps supports the execution of link:http://en.wikipedia.org/wiki/Random_walk[random walks]. In the example below, the traversal starts are vertex 1 and selects one edge to traverse based on a probability distribution generated by the weights of the edges. The output is always a single path as by selecting a single edge, the traverser never splits and continues down a single path in the graph.

[source,groovy]
gremlin> g.V(1).repeat(__.local(
           __.bothE().sample(1).by('weight').otherV()
         )).times(5)
==>v[4]
gremlin> g.V(1).repeat(__.local(
           __.bothE().sample(1).by('weight').otherV()
         )).times(5).path()
==>[v[1], v[2], v[1], v[2], v[1], v[2]]
gremlin> g.V(1).repeat(__.local(
           __.bothE().sample(1).by('weight').otherV()
         )).times(10).path()
==>[v[1], v[4], v[1], v[3], v[4], v[5], v[4], v[5], v[4], v[3], v[4]]

[[select-step]]
Select Step
~~~~~~~~~~~

There are two use cases for `select()`-step (*map*).

. Select labeled steps within a path (as defined by `as()` in a traversal).
. Select objects out of a `Map<String,Object>` flow (i.e. a sub-map).

The first use case is demonstrated via example below.

[source,groovy]
gremlin> g.V().as('a').out().as('b').out().as('c') // no select
==>v[5]
==>v[3]
gremlin> g.V().as('a').out().as('b').out().as('c').select()
==>[a:v[1], b:v[4], c:v[5]]
==>[a:v[1], b:v[4], c:v[3]]
gremlin> g.V().as('a').out().as('b').out().as('c').select('a','b')
==>[a:v[1], b:v[4]]
==>[a:v[1], b:v[4]]
gremlin> g.V().as('a').out().as('b').out().as('c').select('a','b').by('name')
==>[a:marko, b:josh]
==>[a:marko, b:josh]
gremlin> g.V().as('a').out().as('b').out().as('c').select('a') // if the selection is one step, no map is returned
==>v[1]
==>v[1]

The second use case is best understood in terms of <<match-step,`match()`>>-step where the result of `match()` is a `Map<String,Object>` of variable bindings. However, any step that emits a `Map<String,Object>` can be selected. A contrived example is presented below.

[source,groovy]
gremlin> g.V().range(0, 2).as('a').map{[b:1,c:2]} <1>
==>[b:1, c:2]
==>[b:1, c:2]
gremlin> g.V().range(0, 2).as('a').map{[b:1,c:2]}.select() <2>
==>[a:v[1], b:1, c:2]
==>[a:v[2], b:1, c:2]
gremlin> g.V().range(0, 2).as('a').map{[b:1,c:2]}.select('a','c') <3>
==>[a:v[1], c:2]
==>[a:v[2], c:2]
gremlin> g.V().range(0, 2).as('a').map{[b:1,c:2]}.select('c') <4>
==>2
==>2

<1> A contrived example to create a `Map<String,Object>` flow as a foundation for the examples to follow.
<2> Select will grab both labeled steps and `Map<String,Object>` entries.
<3> The same `List<String>` selectivity can be used as demonstrated in the previous example.
<4> If a single selection is used, then the object is emitted not wrapped in a map. Useful for continuing the traversal process without having to do a map projection.

[[using-where-with-select]]
Using Where with Select
^^^^^^^^^^^^^^^^^^^^^^^

Finally, like <<match-step,`match()`>>-step, it is possible to use `where()`, as where is a filter that processes `Map<String,Object>` streams.

[source,groovy]
gremlin> g.V().as('a').out('created').in('created').as('b').select().by('name') <1>
==>[a:marko, b:marko]
==>[a:marko, b:josh]
==>[a:marko, b:peter]
==>[a:josh, b:josh]
==>[a:josh, b:marko]
==>[a:josh, b:josh]
==>[a:josh, b:peter]
==>[a:peter, b:marko]
==>[a:peter, b:josh]
==>[a:peter, b:peter]
gremlin> g.V().as('a').out('created').in('created').as('b').
           select().by('name').
             where('a',neq,'b') <2>
==>[a:marko, b:josh]
==>[a:marko, b:peter]
==>[a:josh, b:marko]
==>[a:josh, b:peter]
==>[a:peter, b:marko]
==>[a:peter, b:josh]
gremlin> g.V().as('a').out('created').in('created').as('b').select(). <3>
              where('a',neq,'b').
              where(__.as('a').out('knows').as('b')).
                select().by('name')
==>[a:marko, b:josh]

<1> A standard `select()` that generates a `Map<String,Object>` of variables bindings in the path (i.e. `a` and `b`) for the sake of a running example.
<2> The `select().by('name')` projects each binding vertex to their name property value and `where()` operates to ensure respective `a` and `b` strings are not the same.
<3> The first `select()` projects a vertex binding set. A binding is filtered if `a` vertex equals `b` vertex. A binding is filtered if `a` doesn't know `b`. The second and final `select()` projects the name of the vertices.

[[shuffle-step]]
Shuffle Step
~~~~~~~~~~~~

Randomizing the order of the traversers at a particular point in the traversal is possible with `shuffle()`-step (*map*).

[source,groovy]
gremlin> __.inject(1,2,3).map{it.get() * 2}
==>2
==>4
==>6
gremlin> __.inject(1,2,3).map{it.get() * 2}.shuffle()
==>4
==>6
==>2
gremlin> __.inject(1,2,3).map{it.get() * 2}.shuffle()
==>6
==>4
==>2

[[simplepath-step]]
SimplePath Step
~~~~~~~~~~~~~~~

image::simplepath-step.png[width=400]

When it is important that a traverser not repeat its path through the graph, `simplePath()`-step should be used (*filter*). The <<path-data-structure,path>> information of the traverser is analyzed and if the path has repeated objects in it, the traverser is filtered. If cyclic behavior is desired, see <<cyclicpath-step,`cyclicPath()`>>.

[source,groovy]
gremlin> g.V(1).both().both()
==>v[1]   // back to v[1]
==>v[4]
==>v[6]
==>v[1]   // back to v[1]
==>v[5]
==>v[3]
==>v[1]   // back to v[1]
gremlin> g.V(1).both().both().simplePath()
==>v[4]
==>v[6]
==>v[5]
==>v[3]
gremlin> g.V(1).both().both().simplePath().path()
==>[v[1], v[3], v[4]]
==>[v[1], v[3], v[6]]
==>[v[1], v[4], v[5]]
==>[v[1], v[4], v[3]]

[[store-step]]
Store Step
~~~~~~~~~~

When link:http://en.wikipedia.org/wiki/Lazy_evaluation[lazy] aggregation is needed, `store()`-step (*sideEffect*) should be used over <<aggregate-step,`aggregate()`>>. The two steps differ in that `store()` does not block and only stores objects in its side-effect collection as they pass through.

[source,groovy]
gremlin> g.V().aggregate('x').limit(1).cap('x')
==>{v[1]=1, v[2]=1, v[3]=1, v[4]=1, v[5]=1, v[6]=1}
gremlin> g.V().store('x').limit(1).cap('x')
==>{v[1]=1, v[2]=1}

It is interesting to note that there are three results in the `store()` side-effect even though the interval selection is for 2 objects. Realize that when the third object is on its way to the `range()` filter (i.e. `[0..1]`), it passes through `store()` and thus, stored before filtered.

[source,groovy]
gremlin> g.E().store().by('weight')
==>{0.5=1, 1.0=2, 0.4=2, 0.2=1}

[[subgraph-step]]
Subgraph Step
~~~~~~~~~~~~~

Extracting a portion of a graph from a larger one for analysis, visualization or other purposes is a fairly common use case for graph analysts and developers. The `subgraph()`-step (*sideEffect*) provides a way to produce an edge-induced subgraph from virtually any traversal.  The following code shows how to produce the "knows" subgraph:

[source,groovy]
----
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> sg = g.E().subgraph { it.label() == 'knows' }.next() <1>
==>tinkergraph[vertices:3 edges:2]
gremlin> sg.E() <2>
==>e[7][1-knows->2]
==>e[8][1-knows->4]
----

<1> As this function produces "edge-induced" subgraphs, the traversal must contain edges in the path.  Those edges found in that path are evaluated by a `Predicate` function to determine if they should be copied to the subgraph in conjunction with their associated vertices.
<2> The subgraph contains only "knows" edges.

A more common subgraphing use case is to get all of the graph structure surrounding a single vertex:

[source,groovy]
----
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> sg = g.V(3).repeat(__.inE().outV()).times(3).emit().subgraph({true}).next()   <1>
==>tinkergraph[vertices:4 edges:4]
gremlin> sg.E()
==>e[8][1-knows->4]
==>e[9][1-created->3]
==>e[11][4-created->3]
==>e[12][6-created->3]
----

<1> Starting at vertex `3`, traverse 3 steps away on in-edges, outputting all of that into the subgraph. Note that if now graph is provided, a `TinkerGraph` is assumed.

[[timelimit-step]]
TimeLimit Step
~~~~~~~~~~~~~~

In many situations, a graph traversal is not about getting an exact answer as its about getting a relative ranking. A classic example is link:http://en.wikipedia.org/wiki/Recommender_system[recommendation]. What is desired is a relative ranking of vertices, not their absolute rank. Next, it may be desirable to have the traversal execute for no more than 750 milliseconds. In such situations, `timeLimit()`-step (*filter*) can be used.

NOTE: The method `clock(int runs, Closure code)` is a utility preloaded in the <<gremlin-console,Gremlin Console>> that can be used to time execution of a body of code.

image::timelimit-step.png[width=400]

[source,groovy]
gremlin> :plugin use tinkerpop.utilities
==>tinkerpop.utilities activated
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().repeat(__.both().groupCount('m')).times(16).cap('m').next().sort{-it.value}
==>v[1]=2744208
==>v[3]=2744208
==>v[4]=2744208
==>v[2]=1136688
==>v[5]=1136688
==>v[6]=1136688
gremlin> clock(1){g.V().repeat(__.both().groupCount('m')).times(16).cap('m').next().sort{-it.value}}
==>11.996000
gremlin> g.V().repeat(__.timeLimit(2).both().groupCount('m')).times(16).cap('m').next().sort{-it.value}
==>v[1]=648473
==>v[3]=647510
==>v[4]=647499
==>v[2]=647421
==>v[5]=268540
==>v[6]=268533
gremlin> clock(1){g.V().repeat(__.timeLimit(2).both().groupCount('m')).times(16).cap('m').next().sort{-it.value}}
==>2.214000

In essence, the relative order is respected, even through the number of traversers at each vertex is not. The primary benefit being that the calculation is guaranteed to complete at the specified time limit (in milliseconds). Finally, note that the internal clock of `timeLimit()`-step starts when the first traverser enters it. When the time limit is reached, any `next()` evaluation of the step will yield a `NoSuchElementException` and any `hasNext()` evaluation will yield `false`.

[[tree-step]]
Tree Step
~~~~~~~~~

From any one element (i.e. vertex or edge), the emanating paths from that element can be aggregated to form a link:http://en.wikipedia.org/wiki/Tree_(data_structure)[tree]. Gremlin provides `tree()`-step (*sideEffect*) for such this situation.

image::tree-step.png[width=450]

[source,groovy]
gremlin> tree = g.V().out().out().tree().next()
==>v[1]={v[4]={v[3]={}, v[5]={}}}

It is important to see how the paths of all the emanating traversers are united to form the tree.

image::tree-step2.png[width=500]

The resultant tree data structure can then be manipulated (see link:http://www.tinkerpop.com/javadocs/current/com/tinkerpop/gremlin/process/graph/step/util/Tree.html[Tree JavaDoc]). For the sake of demonstration, a post-processing lambda is applied in the running example below.

[source,groovy]
gremlin> tree = g.V().out().out().tree().by('name').next()
==>marko={josh={ripple={}, lop={}}}
gremlin> tree['marko']
==>josh={ripple={}, lop={}}
gremlin> tree['marko']['josh']
==>ripple={}
==>lop={}
gremlin> tree.getObjectsAtDepth(3)
==>ripple
==>lop

[[unfold-step]]
Unfold Step
~~~~~~~~~~~

If the object reaching `unfold()` (*flatMap*) is an iterator, iterable, or map, then it is unrolled into a linear form. If not, then the object is simply emitted. Please see <<fold-step,`fold()`>>-step for the inverse behavior.

[source,groovy]
gremlin> g.V(1).out().fold().inject('gremlin',[1.23,2.34])
==>gremlin
==>[1.23, 2.34]
==>[v[3], v[2], v[4]]
gremlin> g.V(1).out().fold().inject('gremlin',[1.23,2.34]).unfold()
==>gremlin
==>1.23
==>2.34
==>v[3]
==>v[2]
==>v[4]

Note that `unfold()` does not recursively unroll iterators. Instead, `repeat()` can be used to for recursive unrolling.

[source,groovy]
gremlin> __.inject(1,[2,3,[4,5,[6]]])
==>1
==>[2, 3, [4, 5, [6]]]
gremlin> __.inject(1,[2,3,[4,5,[6]]]).unfold()
==>1
==>2
==>3
==>[4, 5, [6]]
gremlin> __.inject(1,[2,3,[4,5,[6]]]).repeat(__.unfold()).until{!(it.get() instanceof List)}
==>1
==>2
==>3
==>4
==>5
==>6

[[union-step]]
Union Step
~~~~~~~~~~

image::union-step.png[width=650]

The `union()`-step (*branch*) supports the merging of the results of an arbitrary number of traversals. When a traverser reaches a `union()`-step, it is copied to each of its internal steps. The traversers emitted from `union()` are the outputs of the respective internal traversals.

[source,groovy]
gremlin> g.V(4).union(
            __.in().values('age'),
            __.out().values('lang'))
==>29
==>java
==>java
gremlin> g.V(4).union(
            __.in().values('age'),
            __.out().values('lang')).path()
==>[v[4], v[1], 29]
==>[v[4], v[5], java]
==>[v[4], v[3], java]

[[valuemap-step]]
ValueMap Step
~~~~~~~~~~~~~

The `valueMap()`-step yields a Map representation of the properties of an element.

[source,groovy]
gremlin> g.V().valueMap()
==>[name:[marko], age:[29]]
==>[name:[vadas], age:[27]]
==>[name:[lop], lang:[java]]
==>[name:[josh], age:[32]]
==>[name:[ripple], lang:[java]]
==>[name:[peter], age:[35]]
gremlin> g.V().valueMap('age')
==>[age:[29]]
==>[age:[27]]
==>[:]
==>[age:[32]]
==>[:]
==>[age:[35]]
gremlin> g.V().valueMap('age','blah')
==>[age:[29]]
==>[age:[27]]
==>[:]
==>[age:[32]]
==>[:]
==>[age:[35]]
gremlin> g.E().valueMap()
==>[weight:0.5]
==>[weight:1.0]
==>[weight:0.4]
==>[weight:1.0]
==>[weight:0.4]
==>[weight:0.2]

It is important to note that the map of a vertex maintains a list of values for each key. The map of an edge or vertex-property represents a single property (not a list). The reason is that vertices in TinkerPop3 leverage <<vertex-properties,vertex properties>> which are support multiple values per key. Using the <<the-crew-toy-graph,"The Crew">> toy graph, the point is made explicit.

[source,groovy]
gremlin> g = TinkerFactory.createTheCrew()
==>tinkergraph[vertices:6 edges:14]
gremlin> g.V().valueMap()
==>[name:[marko], location:[san diego, santa cruz, brussels, santa fe]]
==>[name:[stephen], location:[centreville, dulles, purcellville]]
==>[name:[matthias], location:[bremen, baltimore, oakland, seattle]]
==>[name:[daniel], location:[spremberg, kaiserslautern, aachen]]
==>[name:[gremlin]]
==>[name:[tinkergraph]]
gremlin> g.V().has('name','marko').properties('location')
==>vp[location->san diego]
==>vp[location->santa cruz]
==>vp[location->brussels]
==>vp[location->santa fe]
gremlin> g.V().has('name','marko').properties('location').valueMap()
==>[startTime:1997, endTime:2001]
==>[startTime:2001, endTime:2004]
==>[startTime:2004, endTime:2005]
==>[startTime:2005]

If the `id`, `label`, `key`, and `value` of the `Element` is desired, then a boolean triggers its insertion into the returned map.

[source,groovy]
gremlin> g.V().has(label,'person').valueMap(true)
==>[id:1, name:[marko], location:[san diego, santa cruz, brussels, santa fe], label:person]
==>[id:7, name:[stephen], location:[centreville, dulles, purcellville], label:person]
==>[id:8, name:[matthias], location:[bremen, baltimore, oakland, seattle], label:person]
==>[id:9, name:[daniel], location:[spremberg, kaiserslautern, aachen], label:person]
gremlin> g.V().has(label,'person').valueMap(true,'name')
==>[id:1, name:[marko], label:person]
==>[id:7, name:[stephen], label:person]
==>[id:8, name:[matthias], label:person]
==>[id:9, name:[daniel], label:person]
gremlin> g.V().has(label,'person').properties('location').valueMap(true)
==>[value:san diego, id:6, key:location, startTime:1997, endTime:2001]
==>[value:santa cruz, id:7, key:location, startTime:2001, endTime:2004]
==>[value:brussels, id:8, key:location, startTime:2004, endTime:2005]
==>[value:santa fe, id:9, key:location, startTime:2005]
==>[value:centreville, id:10, key:location, startTime:1990, endTime:2000]
==>[value:dulles, id:11, key:location, startTime:2000, endTime:2006]
==>[value:purcellville, id:12, key:location, startTime:2006]
==>[value:bremen, id:13, key:location, startTime:2004, endTime:2007]
==>[value:baltimore, id:14, key:location, startTime:2007, endTime:2011]
==>[value:oakland, id:15, key:location, startTime:2011, endTime:2014]
==>[value:seattle, id:16, key:location, startTime:2014]
==>[value:spremberg, id:17, key:location, startTime:1982, endTime:2005]
==>[value:kaiserslautern, id:18, key:location, startTime:2005, endTime:2009]
==>[value:aachen, id:19, key:location, startTime:2009]
gremlin>

[[vertex-steps]]
Vertex Steps
~~~~~~~~~~~~

image::vertex-steps.png[width=350]

The vertex steps (*flatMap*) are fundamental to the Gremlin language. Via these steps, its possible to "move" on the graph -- i.e. traverse.

* `out(string...)`: Move to the outgoing adjacent vertices given the edge labels.
* `in(string...)`: Move to the incoming adjacent vertices given the edge labels.
* `both(string...)`: Move to both the incoming and outgoing adjacent vertices given the edge labels.
* `outE(string...)`: Move to the outgoing incident edges given the edge labels.
* `inE(string...)`: Move to the incoming incident edges given the edge labels.
* `bothE(string...)`: Move to both the incoming and outgoing incident edges given the edge labels.
* `outV()`: Move to the outgoing vertex.
* `inV()`: Move to the incoming vertex.
* `bothV()`: Move to both vertices.
* `otherV()` : Move to the vertex that was not the vertex that was moved from.

[source,groovy]
gremlin> g.V(4)
==>v[4]
gremlin> g.V(4).outE()  // all outgoing edges
==>e[10][4-created->5]
==>e[11][4-created->3]
gremlin> g.V(4).inE('knows')  // all incoming knows-edges
==>e[8][1-knows->4]
gremlin> g.V(4).inE('created') // all incoming created-edges
gremlin> g.V(4).bothE('knows','created','blah')
==>e[10][4-created->5]
==>e[11][4-created->3]
==>e[8][1-knows->4]
gremlin> g.V(4).bothE('knows','created','blah').otherV()
==>v[5]
==>v[3]
==>v[1]
gremlin> g.V(4).both('knows','created','blah')
==>v[5]
==>v[3]
==>v[1]
gremlin> g.V(4).outE().inV() // moving forward touching edges,vertices
==>v[5]
==>v[3]
gremlin> g.V(4).out()  // moving forward only touching vertices
==>v[5]
==>v[3]
gremlin> g.V(4).inE().outV()
==>v[1]
gremlin> g.V(4).inE().bothV()
==>v[1]
==>v[4]

[[traversalstrategy]]
TraversalStrategy
-----------------

image:traversal-strategy.png[width=125,float=right] A `TraversalStrategy` can analyze a `Traversal` and mutate the traversal as it deems fit. This is useful in two situations:

 * There is a more efficient way to express the traversal at the TinkerPop3 level.
 * There is a more efficient way to express the traversal at the graph vendor level.

A simple TraversalStrategy is the `IdentityRemovalStrategy` and it is a type-1 strategy defined as follows:

[source,java]
----
public class IdentityRemovalStrategy extends AbstractTraversalStrategy {

    private static final IdentityRemovalStrategy INSTANCE = new IdentityRemovalStrategy();

    private IdentityRemovalStrategy() {
    }

    @Override
    public void apply(final Traversal.Admin<?, ?> traversal, final TraversalEngine engine) {
        if (!TraversalHelper.hasStepOfClass(IdentityStep.class, traversal))
            return;
        TraversalHelper.getStepsOfClass(IdentityStep.class, traversal).stream()
                .filter(step -> !TraversalHelper.isLabeled(step))
                .forEach(step -> traversal.removeStep(step));
    }

    public static IdentityRemovalStrategy instance() {
        return INSTANCE;
    }
}
----

This strategy simply removes any unlabeled `IdentityStep` steps in the Traversal as `aStep().identity().identity().bStep()` is equivalent to `aStep().bStep()`. For those traversal strategies that require other strategies to execute prior or post to the strategy, then the following two methods can be defined in `TraversalStrategy` (with defaults being an empty set).

[source,java]
public Set<Class<? extends TraversalStrategy>> applyPrior();
public Set<Class<? extends TraversalStrategy>> applyPost();

Type-2 strategies are defined by graph vendors who implement TinkerPop3.

[source,groovy]
g.V().has('name','marko')

The expression above can be executed in a `O(|V|)` or `O(log(|V|)` fashion in <<tinkergraph-gremlin,TinkerGraph>> depending on whether there is or is not an index defined for "name."

[source,java]
----
public class TinkerGraphStepStrategy extends AbstractTraversalStrategy {

    private static final TinkerGraphStepStrategy INSTANCE = new TinkerGraphStepStrategy();

    private TinkerGraphStepStrategy() {
    }

    @Override
    public void apply(final Traversal.Admin<?, ?> traversal, final TraversalEngine engine) {
        if (engine.equals(TraversalEngine.COMPUTER))
            return;

        final Step<?, ?> startStep = TraversalHelper.getStart(traversal);
        if (startStep instanceof GraphStep) {
            final GraphStep<?> originalGraphStep = (GraphStep) startStep;
            final TinkerGraphStep<?> tinkerGraphStep = new TinkerGraphStep<>(originalGraphStep);
            TraversalHelper.replaceStep(startStep, tinkerGraphStep, traversal);

            Step<?, ?> currentStep = tinkerGraphStep.getNextStep();
            while (true) {
                if (currentStep instanceof HasContainerHolder) {
                    tinkerGraphStep.hasContainers.addAll(((HasContainerHolder) currentStep).getHasContainers());
                    if (TraversalHelper.isLabeled(currentStep)) {
                        final IdentityStep identityStep = new IdentityStep<>(traversal);
                        identityStep.setLabel(currentStep.getLabel());
                        TraversalHelper.insertAfterStep(identityStep, currentStep, traversal);
                    }
                    traversal.removeStep(currentStep);
                } else if (currentStep instanceof IdentityStep) {
                    // do nothing
                } else {
                    break;
                }
                currentStep = currentStep.getNextStep();
            }
        }
    }

    public static TinkerGraphStepStrategy instance() {
        return INSTANCE;
    }
}
----


The traversal is redefined by simply taking a chain of `has()`-steps after `g.V()` (`TinkerGraphStep`) and providing them to `TinkerGraphStep`. Then its up to TinkerGraphStep to determine if an appropriate index exists. In the code below, review the `vertices()` method and note how if an index exists, for a particular `HasContainer`, then that index is first queried before the remaining `HasContainer` filters are serially applied.

[source,groovy]
gremlin> t = g.V().has('name','marko'); null
==>null
gremlin> t.toString()
==>[GraphStep(vertex), HasStep([name,eq,marko])]
gremlin> t.iterate(); null
==>null
gremlin> t.toString()
==>[TinkerGraphStep(vertex,[[name,eq,marko]])]

Domain Specific Languages
-------------------------

CAUTION: As of TinkerPop x.y.z, the presented domain specific language framework has not been fully flushed out. Expect changes to the API until this "caution"-note is removed.

image:gremlin-quill.png[width=200,float=right] The super interface of GraphTraversal is `Traversal`. It is possible for developers to create domain specific traversals by extending Traversal. For example, a `SocialTraversal` example is provided below.

[source,java]
----
 public interface SocialTraversal<S, E> extends Traversal<S, E> {

     public SocialTraversal<S, Vertex> people(final String name);

     public default SocialTraversal<S, Vertex> knows() {
         final FlatMapStep<Vertex, Vertex> flatMapStep = new FlatMapStep<>(this);
         flatMapStep.setFunction(v -> v.get().out("knows"));
         return (SocialTraversal) this.asAdmin().addStep(flatMapStep);
     }

     public default SocialTraversal<S, Vertex> created() {
         final FlatMapStep<Vertex, Vertex> flatMapStep = new FlatMapStep<>(this);
         flatMapStep.setFunction(v -> v.get().out("created"));
         return (SocialTraversal) this.asAdmin().addStep(flatMapStep);
     }

     public default SocialTraversal<S, String> name() {
         MapStep<Vertex, String> mapStep = new MapStep<>(this);
         mapStep.setFunction(v -> v.get().<String>value("name"));
         return (SocialTraversal) this.asAdmin().addStep(mapStep);
     }

     public static <S> SocialTraversal<S, S> of(final Graph graph) {
         return new DefaultSocialTraversal<>(graph);
     }

     public class DefaultSocialTraversal<S, E> extends DefaultTraversal<S, E> implements SocialTraversal<S, E> {
         private final Graph graph;

         public DefaultSocialTraversal(final Graph graph) {
             super(Graph.class);
             this.graph = graph;
         }

         public SocialTraversal<S, Vertex> people(final String name) {
             return (SocialTraversal) this.asAdmin().addStep(new StartStep<>(this, this.graph.V().has("name", name)));
         }

     }
 }
----

This traversal definition can now be used as follows.

[source,groovy]
gremlin> import com.tinkerpop.gremlin.tinkergraph.structure.TinkerFactory.SocialTraversal
==>...
gremlin> g.of(SocialTraversal).people("marko").knows().name()
==>vadas
==>josh

By extending `Traversal`, users can create a DSL that is respective of the semantics of their data. Instead of querying in terms of vertices/edges/properties, they can query in terms of, for example, people, their friends, and their names.

