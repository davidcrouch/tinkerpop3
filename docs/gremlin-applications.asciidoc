[[gremlin-applications]]
Gremlin Applications
====================

Gremlin applications represent tools that are built on top of the core APIs to help expose common functionality to users when working with graphs.  There are two key applications:

. Gremlin Console - A link:http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop[REPL] environment for interactive development and analysis
. Gremlin Server - A server that hosts script engines thus enabling remote Gremlin execution

Gremlin is designed to be extensible, making it possible for users and vendors to customize it to their needs.  Such extensibility is also found in the Gremlin Console and Server, where a universal plugin system makes it possible to extend their capabilities.  One of the important aspects of the plugin system is the ability to help the user install the plugins through the command line thus automating the process of gathering dependencies and other error prone activities.

The process of plugin installation is handled by link:http://groovy.codehaus.org/Grape[Grape], which helps resolve dependencies into the classpath.  It is therefore important to ensure that Grape is properly configured in order to use the automated capabilities of plugin installation.  Grape is configured by `~/.groovy/grapeConfig.xml` and generally speaking, if that file is not present, the default settings will suffice.  However, they will not suffice if a required dependency is not in one of the default configured repositories. Please see the link:http://groovy.codehaus.org/Grape[Custom Ivy Settings] section of the Grape documentation for more details on the defaults.  TinkerPop recommends the following configuration in that file:

[source,xml]
<ivysettings>
  <settings defaultResolver="downloadGrapes"/>
  <resolvers>
    <chain name="downloadGrapes">
      <filesystem name="cachedGrapes">
        <ivy pattern="${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml"/>
        <artifact pattern="${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
      </filesystem>
      <ibiblio name="codehaus" root="http://repository.codehaus.org/" m2compatible="true"/>
      <ibiblio name="central" root="http://central.maven.org/maven2/" m2compatible="true"/>
      <ibiblio name="java.net2" root="http://download.java.net/maven/2/" m2compatible="true"/>
      <ibiblio name="hyracs-releases" root="http://obelix.ics.uci.edu/nexus/content/groups/hyracks-public-releases/" m2compatible="true"/>
    </chain>
  </resolvers>
</ivysettings>

Note that if the intention is to work with TinkerPop snapshots then the file should also include:

[source,xml]
<ibiblio name="sonatype-snapshots" root="https://oss.sonatype.org/content/repositories/snapshots/" m2compatible="true"/>

Additionally, the Graph configuration can also be modified to include the local system's Maven `.m2` directory by including:

[source,xml]
<ibiblio name="local" root="file:${user.home}/.m2/repository/" m2compatible="true"/>

CAUTION: If building TinkerPop from source, be sure to clear TinkerPop-related jars from the `~/.groovy/grapes` directory as they can become stale on some systems and not re-import properly from the local `.m2` after fresh rebuilds.

[[gremlin-console]]
Gremlin Console
---------------

image:gremlin-console.png[width=325,float=right] The Gremlin Console is an interactive terminal or link:http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop[REPL] that can be used to traverse graphs and interact with the data that they contain.  It represents the most common method for performing ad-hoc graph analysis, small to medium sized data loading projects and other exploratory functions.  The Gremlin Console is highly extensible, featuring a rich plugin system that allows new tools, commands, link:http://en.wikipedia.org/wiki/Domain-specific_language[DSLs], etc. to be exposed to users.

To start the Gremlin Console, run `gremlin.sh` or `gremlin.bat`:

[source,text]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin loaded: tinkerpop.server
plugin loaded: tinkerpop.utilities
plugin loaded: tinkerpop.tinkergraph
gremlin>
----

NOTE: If the above plugins are not loaded then they will need to be enabled or else certain examples will not work. If using the standard Gremlin Console distribution, then the plugins should be enabled by default.  See below for more information on the `:plugin use` command to manually enable plugins. These plugins, with the exception of `tinkerpop.tinkergraph`, cannot be removed from the Console as they are a part of the `gremlin-console.jar` itself.  These plugins can only be deactivated.

The Gremlin Console is loaded and ready for commands. Recall that the console hosts the Gremlin-Groovy language.  Please review link:http://groovy.codehaus.org/[Groovy] for help on Groovy-related constructs. In short, Groovy is a superset of Java. What works in Java, works in Groovy. However, Groovy provides many shorthands to make it easier to interact with the Java API.  Moreoever, Gremlin provides many neat shorthands to make it easier to express paths through a property graph.

[source,groovy]
----
gremlin> i = 'goodbye'
==>goodbye
gremlin> j = 'self'
==>self
gremlin> i + " " + j
==>goodbye self
gremlin> "${i} ${j}"
==>goodbye self
----

The "toy" graph provides a way to get started with Gremlin quickly.

[source,groovy]
----
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V()
==>v[1]
==>v[2]
==>v[3]
==>v[4]
==>v[5]
==>v[6]
gremlin> g.V().values('name')
==>marko
==>vadas
==>lop
==>josh
==>ripple
==>peter
gremlin> g.V().has('name','marko').out('knows').values('name')
==>vadas
==>josh
----

Console Commands
~~~~~~~~~~~~~~~~

In addition to the standard commands of the link:http://groovy.codehaus.org/Groovy+Shell[Groovy Shell], Gremlin adds some other useful operations.  The following table outlines the most commonly used commands:

[width="100%",cols="3,^2,10",options="header"]
|=========================================================
|Command |Alias |Description
|:help |:? |Displays list of commands and descriptions.  When followed by a command name, it will display more specific help on that particular item.
|:exit |:x |Ends the Console session.
|import |:i |Import a class into the Console session.
|:clear |:c |Sometimes the Console can get into a state where the command buffer no longer understands input (e.g. a misplaced `(` or `}`).  Use this command to clear that buffer.
|:load |:l |Load a file or URL into the command buffer for execution.
|:install |:+ |Imports a maven library and its dependencies into the Console.
|:uninstall |:- |Removes a maven library and its dependencies. A restart of the console is required for removal to fully take effect.
|:plugin |:pin |Plugin management functions to list, activate and deactivate available plugins.
|:remote |:rem |Configures a "remote" context where Gremlin or results of Gremlin will be processed via usage of `:submit`.
|:submit |:> |Submit Gremlin to the currently active context defined by `:remote`.
|=========================================================

Dependencies and Plugin Usage
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Gremlin Console can dynamically load external code libraries and make them available to the user.  Furthermore, those dependencies may contain Gremlin plugins which can expand the language, provide useful functions, etc.  These important console features are managed by the `:install` and `:plugin` commands.

The following Gremlin Console session demonstrates the basics of these features:

[source,groovy]
----
gremlin> :plugin list  <1>
==>tinkerpop.server[active]
==>tinkerpop.gephi
==>tinkerpop.utilities[active]
==>tinkerpop.sugar
==>tinkerpop.tinkergraph[active]
gremlin> :plugin use tinkerpop.sugar  <2>
==>tinkerpop.sugar activated
gremlin> :install com.tinkerpop neo4j-gremlin x.y.z  <3>
==>loaded: [com.tinkerpop, neo4j-gremlin, x.y.z]
gremlin> :plugin list <4>
==>tinkerpop.server[active]
==>tinkerpop.gephi
==>tinkerpop.utilities[active]
==>tinkerpop.sugar
==>tinkerpop.tinkergraph[active]
==>tinkerpop.neo4j
gremlin> :plugin use tinkerpop.neo4j <5>
==>tinkerpop.neo4j activated
gremlin> :plugin list <6>
==>tinkerpop.server[active]
==>tinkerpop.gephi
==>tinkerpop.sugar[active]
==>tinkerpop.utilities[active]
==>tinkerpop.neo4j[active]
==>tinkerpop.tinkergraph[active]
----

<1> Show a list of "available" plugins.  The list of "available" plugins is determined by the classes available on the Console classpath.  Plugins need to be "active" for their features to be available.
<2> To make a plugin "active" execute the `:plugin use` command and specify the name of the plugin to enable.
<3> Sometimes there are external dependencies that would be useful within the Console.  To bring those in, execute `:install` and specify the Maven coordinates for the dependency.  
<4> Note that there is a "tinkerpop.neo4j" plugin available, but it is not yet "active".
<5> Again, to use the "tinkerpop.neo4j" plugin, it must be made "active" with `:plugin use`.
<6> Now when the plugin list is displayed, the "tinkerpop.neo4j" plugin is displayed as "active".

CAUTION: Plugins must be compatible with the version of the Gremlin Console (or Gremlin Server) being used.  Attempts to use incompatible versions cannot be guaranteed to work.  Moreover, be prepared for dependency conflicts in third-party plugins, that may only be resolved via manual jar removal from the `ext/{plugin}` directory.

TIP: It is possible to manage plugin activation and deactivation by manually editing the `ext/plugins.txt` file which contains the class names of the "active" plugins.  It is also possible to clear dependencies added by `:install` by deleting them from the `ext` directory.

[[gremlin-server]]
Gremlin Server
--------------

image:gremlin-server.png[width=400,float=right] Gremlin Server provides a way to remotely execute Gremlin scripts against one or more `Graph` instances hosted within it.  The benefits of using Gremlin Server include:

* Allows any Gremlin Structure-enabled graph to exist as a standalone server, which in turn enables the ability for multiple clients to communicate with the same graph database.
* Enables execution of ad-hoc queries through remotely submitted Gremlin scripts.
* Allows for the hosting of Gremlin-based DSLs (Domain Specific Language) that expand the Gremlin language to match the language of the application domain, which will help support common graph use cases such as searching, ranking, and recommendation.
* Provides a method for Non-JVM languages (e.g. Python, .NET, etc.) to communicate with the TinkerPop stack.
* Exposes numerous methods for extension and customization to include serialization options, remote commands, etc.

NOTE: Gremlin Server is the replacement for link:http://rexster.tinkerpop.com[Rexster].

By default, communication with Gremlin Server occurs over link:http://en.wikipedia.org/wiki/WebSocket[WebSockets] and exposes a custom subprotocol for interacting with the server.

[[connecting-via-console]]
Connecting via Console
~~~~~~~~~~~~~~~~~~~~~~

The most direct way to get started with Gremlin Server is to issue it some remote Gremlin scripts from the Gremlin Console.  To do that, first start Gremlin Server:

[source,text]
----
$ bin/gremlin-server.sh conf/gremlin-server-modern.yaml
[INFO] GremlinServer -
         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----

[INFO] GremlinServer - Configuring Gremlin Server from conf/gremlin-server-modern.yaml
[INFO] MetricManager - Configured Metrics Slf4jReporter configured with interval=180000ms and loggerName=com.tinkerpop.gremlin.server.Settings$Slf4jReporterMetrics
[INFO] GremlinServer$WebSocketServerInitializer - Configured application/vnd.gremlin-v1.0+kryo with com.tinkerpop.gremlin.driver.ser.KryoMessageSerializerV1d0
[INFO] GremlinServer$WebSocketServerInitializer - Configured application/vnd.gremlin-v1.0+kryo-stringd with com.tinkerpop.gremlin.driver.ser.KryoMessageSerializerV1d0
[INFO] Graphs - Graph [g] was successfully configured via [config/tinkergraph-empty.properties].
[INFO] GremlinExecutor - Getting dependencies for [[org.apache.commons, commons-math3, 3.2]]
[INFO] GremlinExecutor - Initialized gremlin-groovy ScriptEngine with scripts/generate-modern.groovy
[INFO] GremlinServer$WebSocketServerInitializer - Initialized GremlinExecutor and configured ScriptEngines.
[INFO] GremlinServer$WebSocketServerInitializer - Initialized Gremlin thread pool.  Threads in pool named with pattern gremlin-*
[INFO] GremlinServer - Gremlin Server configured with worker thread pool of 1 and boss thread pool of 1
[INFO] GremlinServer - Channel started at port 8182.
----

Gremlin Server is configured by the provided link:http://www.yaml.org/[YAML] file `conf/gremlin-server-modern.yaml`.  That file tells Gremlin Server many things such as:

* The host and port to serve on
* Thread pool sizes
* Where to report metrics gathered by the server
* The serializers to make available
* The Gremlin `ScriptEngine` instances to expose and external dependencies to inject into them
* `Graph` instances to expose

The log messages that printed above show a number of things, but most importantly, there is a `Graph` instance named `g` that is exposed in Gremlin Server.  This graph is an in-memory TinkerGraph and was empty at the start of the server.  An initialization script at `scripts/generate-modern.groovy` was executed during startup.  It's contents are as follows:

[source,groovy]
----
include::{basedir}/gremlin-server/scripts/generate-modern.groovy[]
----

This script loads the "modern" graph into the empty TinkerGraph instance, preparing it for use.  With Gremlin Server running it is now possible to issue some scripts to it for processing.  Start Gremlin Console as follows:

[source,text]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin>
----

The console has the notion of a "remote", which represents a place a script will be sent from the console to be evaluated elsewhere in some other context (e.g. Gremlin Server, Hadoop, etc.).  To create a remote in the console, do the following:

[source,groovy]
----
gremlin> :remote connect tinkerpop.server conf/remote.yaml
==>Connected - localhost/127.0.0.1:8182
----

The `:remote` command shown above displays the current status of the remote connection.  This command can also be used to configure a new connection and change other related settings.  To actually send a script to the server a different command is required:

[source,groovy]
----
gremlin> :> g.V().values('name')
==>marko
==>vadas
==>lop
==>josh
==>ripple
==>peter
gremlin> :> g.V().has('name','marko').out('created').values('name')
==>lop
gremlin> :> g.E().label().groupCount()
==>{created=4, knows=2}
gremlin> result
==>result{object={created=4, knows=2} class=java.lang.String}
gremlin> :remote close
==>Removed - gremlin server - [localhost/127.0.0.1:8182]
----

The `:>` command, which is a shorthand for `:submit`, sends the script to the server to execute there.  Results are wrapped in an `Result` object which is a just a holder for each individual result.  The `class` shows the data type for the containing value.  Note that the last script sent was supposed to return a `Map`, but its `class` is `java.lang.String`.  By default, the connection is configured to only return text results.  In other words, Gremlin Server is using `toString` to serialize all results back to the console.  This enables virtually any object on the server to be returned to the console, but it doesn't allow the opportunity to work with this data in any way in the console itself.  A different configuration of the `:remote` is required to get the results back as "objects":

[source,groovy]
----
gremlin> :remote connect tinkerpop.server conf/remote-objects.yaml <1>
==>connected - localhost/127.0.0.1:8182
gremlin> :remote list <2>
==>0 - Gremlin Server - [localhost/127.0.0.1:8182]
==>*1 - Gremlin Server - [localhost/127.0.0.1:8182]
gremlin> :> g.E().label().groupCount() <3>
==>[created:4, knows:2]
gremlin> m = result[0].object <4>
==>created=4
==>knows=2
gremlin> m.sort{it.value}
==>knows=2
==>created=4
gremlin> script = """
                  matthias = g.addVertex('name','matthias')
                  matthias.addEdge('co-creator',g.V().has('name','marko').next())
                  """
gremlin> :> @script   <5>
==>e[14][12-co-creator->1]
gremlin> :> g.V().has('name','matthias').out('co-creator').values('name')
==>marko
gremlin> :remote close
==>Removed - gremlin server - [localhost/127.0.0.1:8182]
----

<1> This configuration file specifies that results should be deserialized back into an `Object` in the Console with the caveat being that the server and console both know how to serialize and deserialize the result to be returned.
<2> There are now two configured remote connections.  The one marked by an asterisk is the one that was just created and denotes the current one that `:sumbit` will react to.
<3> When the script is executed again, the `class` is no longer shown to be a `java.lang.String`.  It is instead a `java.util.HashMap`.
<4> The last result of a remote script is always stored in the reserved variable `result`, which allows access to the `Result` and by virtue of that, the `Map` itself.
<5> If the submission requires multiple-lines to express, then a multi-line string can be created. The `:>` command realizes that the user is referencing a variable via `@` and submits the string script.

TIP: In Groovy, `""" text """` is a convenient way to create a multi-line string and works well in concert with `:> @variable`. Note that this model of submitting a string variable works for all `:>` based plugins, not just Gremlin Server.

Connecting via Java
~~~~~~~~~~~~~~~~~~~

[source,xml]
----
<dependency>
   <groupId>com.tinkerpop</groupId>
   <artifactId>gremlin-driver</artifactId>
   <version>x.y.z</version>
</dependency>
----

image:gremlin-java.png[width=175,float=left] TinkerPop3 comes equipped with a reference client for Java-based applications.  It is referred to as Gremlin Driver, which enables applications to send requests to Gremlin Server and get back results.

CAUTION: Gremlin Driver is currently under heavy development.  The API and configuration options are subject to drastic and breaking change.

Gremlin code is sent to the server from a `Client` instance.  A `Client` is created as follows:

[source,java]
----
Cluster cluster = Cluster.open();  <1>
Client client = cluster.connect(); <2>
----

<1> Opens a reference to `localhost` - note that there are many configuration options available in defining a `Cluster` object.
<2> Creates a `Client` given the configuration options of the `Cluster`.

Once a `Client` instance is ready, it is possible to issue some Gremlin:

[source,java]
----
ResultSet results = client.submit("[1,2,3,4]");  <1>
results.stream().map(i -> i.get(Integer.class) * 2);       <2>

CompletableFuture<List<Result>> results = client.submit("[1,2,3,4]").all();  <3>

CompletableFuture<ResultSet> future = client.submitAsync("[1,2,3,4]"); <4>

Map<String,Object> params = new HashMap<>()
params.put("x",4)
client.submit("[1,2,3,x]", params); <5>
----

<1> Submits a script that simply returns a `List` of integers.  This method blocks until the request is written to the server and a `ResultSet` is constructed.
<2> Even though the `ResultSet` is constructed, it does not mean that the server has sent back the results (or even evaluated the script potentially).  The `ResultSet` is just a holder that is awaiting the results from the server.  In this case, they are streamed from the server as they arrive.
<3> Submit a script, get a `ResultSet`, then return a `CompletableFuture` that will be called when all results have been returned.
<4> Submit a script asynchronously without waiting for the request to be written to the server.
<5> Parameterized request are considered the most efficient way to send Gremlin to the server as they can be cached, which will boost performance and reduce resources required on the server.


Connecting via REST
~~~~~~~~~~~~~~~~~~~

image:gremlin-rexster.png[width=225,float=left] While the default behavior for Gremlin Server is to provide a WebSockets-based connection, it can also be configured to support link:http://en.wikipedia.org/wiki/Representational_state_transfer[REST].  The REST endpoint provides for a communication protocol familiar to most developers, with a wide support of programming languages, tools and libraries for accessing it.  As a result, REST provides a fast way to get started with Gremlin Server.   It also may represent an easier upgrade path from link:http://rexster.tinkerpop.com/[Rexster] as the API for the endpoint is very similar to Rexster's link:https://github.com/tinkerpop/rexster/wiki/Gremlin-Extension[Gremlin Extension].

Gremlin Server provides for a single REST endpoint - a Gremlin evaluator - which allows the submission of a Gremlin script as a request.  For each request, it returns a response containing the serialized results of that script.  To enable this endpoint, Gremlin Server needs to be configured with the `HttpChannelizer`, which replaces the default `WebSocketChannelizer`, in the configuration file:

[source,yaml]
channelizer: com.tinkerpop.gremlin.server.channel.HttpChannelizer

This setting is already configured in the `gremlin-server-rest-modern.yaml` file that is packaged with the Gremlin Server distribution.  To utilize it, start Gremlin Server as follows:

[source,text]
bin/gremlin-server.sh conf/gremlin-server-rest-modern.yaml

Once the server has started, issue a request.  Here's an example with link:http://curl.haxx.se/[cURL]:

[source,text]
$ curl "http://localhost:8182?gremlin=100-1"

which returns:

[source,js]
{
  "result":{"data":99,"meta":{}},
  "requestId":"0581cdba-b152-45c4-80fa-3d36a6eecf1c",
  "status":{"code":200,"attributes":{},"message":""}
}

The above example showed a `GET` operation, but the preferred method for this endpoint is `POST`:

[source,text]
curl -X POST -d "{\"gremlin\":\"100-1\"}" "http://localhost:8182"

which returns:

[source,js]
{
  "result":{"data":99,"meta":{}},
  "requestId":"ef2fe16c-441d-4e13-9ddb-3c7b5dfb10ba",
  "status":{"code":200,"attributes":{},"message":""}
}

It is also preferred that Gremlin scripts be parameterized when possible via `bindings`:

[source,text]
curl -X POST -d "{\"gremlin\":\"100-x\", \"bindings\":{\"x\":1}}" "http://localhost:8182"

The `bindings` argument is a `Map` of variables where the keys become available as variables in the Gremlin script.  Note that parameterization of requests is critical to performance, as repeated script compilation can be avoided on each request.

NOTE: It is possible to pass bindings via `GET` based requests.  All query string arguments besides the "gremlin" key containing the script to execute will be treated as bindings.  The caveat is that these arguments will always be treated as `String` values.  To ensure that data types are preserved or to pass complex objects such as lists or maps, use `POST` which will at least support the allowed JSON data types.

Finally, as Gremlin Server can host multiple `ScriptEngine` instances (e.g. `gremlin-groovy`, `nashorn`), it is possible to define the language to utilize to process the request:

[source,text]
curl -X POST -d "{\"gremlin\":\"100-x\", \"language\":\"gremlin-groovy\", \"bindings\":{\"x\":1}}" "http://localhost:8182"

By default this value is set to `gremlin-groovy`.  If using a `GET` operation, this value can be set as a query string argument with by setting the `language` key.

CAUTION: Consider the size of the result of a submitted script being returned from the REST endpoint.  A script that iterates thousands of results will serialize each of those in memory into a single JSON result set.  It is quite possible that such a script will generate `OutOfMemoryError` exceptions on the server.  Consider the default WebSockets configuration, which supports streaming, if that type of use case is required.

Configuring
~~~~~~~~~~~

As mentioned earlier, Gremlin Server is configured though a YAML file.  By default, Gremlin Server will look for a file called `config/gremlin-server.yaml` to configure itself on startup.  To override this default, supply the file to use to `bin/gremlin-server.sh` as in:

[source,text]
----
bin/gremlin-server.sh conf/gremlin-server-min.yaml
----

The `gremlin-server.sh` file also serves a second purpose.  It can be used to "install" dependencies to the Gremlin Server path.  For example, to be able to configure and use other `Graph` implementations, the dependencies must be made available to Gremlin Server.  To do this, use the `-i` switch and supply the Maven coordinates for the dependency to "install".  For example, to use Neo4j in Gremlin Server:

[source,text]
----
bin/gremlin-server.sh -i com.tinkerpop neo4j-gremlin x.y.z
----

This command will "grab" the appropriate dependencies and copy them to the `ext` directory of Gremlin Server, which will then allow them to be "used" the next time the server is started.  To uninstall dependencies, simply delete them from the `ext` directory.

The following table describes the various configuration options that Gremlin Server expects:

[width="100%",cols="3,10,^2",options="header"]
|=========================================================
|Key |Description |Default
|channelizer |Defines the `Channelizer` implementation to use.  A `Channelizer` is a "channel initializer" which Gremlin Server uses to define the type of processing pipeline to use.  By allowing different `Channelizer` implementations, Gremlin Server can support different communication protocols (e.g. Websockets, Java NIO, etc.). |WebSocketChannelizer,HttpChannelizer
|graphs |A `Map` of `Graph` configuration files where the key of the `Map` becomes the name to which the `Graph` will be bound and the value is the file name of a `Graph` configuration file. |_none_
|gremlinPool |The number of "Gremlin" threads available to execute actual scripts in a `ScriptEngine`. This pool represents the workers available to handle blocking operations in Gremlin Server. |8
|host |The name of the host to bind the server to. |localhost
|metrics.consoleReporter.enabled |Turns on console reporting of metrics. |false
|metrics.consoleReporter.interval |Time in milliseconds between reports of metrics to console. |180000
|metrics.csvReporter.enabled |Turns on CSV reporting of metrics. |false
|metrics.csvReporter.fileName |The file to write metrics to. |_none_
|metrics.csvReporter.interval |Time in milliseconds between reports of metrics to file. |180000
|metrics.gangliaReporter.addressingMode |Set to `MULTICAST` or `UNICAST`. |_none_
|metrics.gangliaReporter.enabled |Turns on Ganglia reporting of metrics. |false
|metrics.gangliaReporter.host |Define the Ganglia host to report Metrics to. |localhost
|metrics.gangliaReporter.interval |Time in milliseconds between reports of metrics for Ganglia. |180000
|metrics.gangliaReporter.port |Define the Ganglia port to report Metrics to. |8649
|metrics.graphiteReporter.enabled |Turns on Graphite reporting of metrics. |false
|metrics.graphiteReporter.host |Define the Graphite host to report Metrics to. |localhost
|metrics.graphiteReporter.interval |Time in milliseconds between reports of metrics for Graphite. |180000
|metrics.graphiteReporter.port |Define the Graphite port to report Metrics to. |2003
|metrics.graphiteReporter.prefix |Define a "prefix" to append to metrics keys reported to Graphite. |_none_
|metrics.jmxReporter.enabled |Turns on JMX reporting of metrics. |false
|metrics.slf4jReporter.enabled |Turns on SLF4j reporting of metrics. |false
|metrics.slf4jReporter.interval |Time in milliseconds between reports of metrics to SLF4j. |180000
|plugins |A list of plugins that should be activated on server startup in the available script engines. It assumes that the plugins are in Gremlin Server's classpath. |_none_
|port |The port to bind the server to. |8182
|processors |A `List` of `Map` settings, where each `Map` represents a `OpProcessor` implementation to use along with its configuration. |_none_
|processors[X].className |The full class name of the `OpProcessor` implementation. |_none_
|processors[X].config |A `Map` containing `OpProcessor` specific configurations. |_none_
|resultIterationBatchSize |Defines the size in which the result of a request is "batched" back to the client.  In other words, if set to `1`, then a result that had ten items in it would get each result sent back individually.  If set to `2` the same ten results would come back in five batches of two each. |64
|scriptEngines |A `Map` of `ScriptEngine` implementations to expose through Gremlin Server, where the key is the name given by the `ScriptEngine` implementation.  The key must match the name exactly for the `ScriptEngine` to be constructed.  The value paired with this key is itself a `Map` of configuration for that `ScriptEngine`.  |_none_
|scriptEngines.<name>.imports |A comma separated list of classes/packages to make available to the `ScriptEngine`. |_none_
|scriptEngines.<name>.staticImports |A comma separated list of "static" imports to make available to the `ScriptEngine`. |_none_
|scriptEngines.<name>.scripts |A comma separated list of script files to execute on `ScriptEngine` initialization. Modifications to `Graph` instance references will be stored globally in Gremlin Server, therefore it is possible to use initialization scripts to add Graph Strategies or create entirely new `Graph` instances all together. |_none_
|scriptEngines.<name>.config |A `Map` of configuration settings for the `ScriptEngine`.  These settings are dependent on the `ScriptEngine` implementation being used. |_none_
|scriptEvaluationTimeout |The amount of time in milliseconds before a script evaluation times out. The notion of "script evaluation" refers to the time it takes for the `ScriptEngine` to do its work and *not* any additional time it takes for the result of the evaluation to be iterated and serialized. |30000
|serializers |A `List` of `Map` settings, where each `Map` represents a `MessageSerializer` implementation to use along with its configuration. |_none_
|serializers[X].className |The full class name of the `MessageSerializer` implementation. |_none_
|serializers[X].config |A `Map` containing `MessageSerializer` specific configurations. |_none_
|serializedResponseTimeout |The amount of time in milliseconds before a response serialization times out.  The notion of "response serialization" refers to the time it takes for Gremlin Server to iterate an entire result after the script is evaluated in the `ScriptEngine`. |30000
|ssl.enabled |Determines if SSL is turned on or not. |false
|threadPoolBoss |The number of threads available to Gremlin Server for accepting connections. Should always be set to `1`. |1
|threadPoolWorker |The number of threads available to Gremlin Server for processing non-blocking reads and writes. |1
|=========================================================

Tuning
~~~~~~

image:gremlin-handdrawn.png[width=120,float=right] Tuning Gremlin Server for a particular environment may require some simple trial-and-error, but the following represent some basic guidelines that might be useful:

* A "good" setting for `threadPoolWorker` is `2*number of cores`.  If a smaller setting can be used there while still achieving performance needs, then choose the smaller setting.  If a larger setting is needed, then consider a server with more cores.
* The "right" size of the `gremlinPool` setting is somewhat dependent on the type of scripts that will be processed by Gremlin Server.  As requests arrive to Gremlin Server they are decoded and queued to be processed by threads in this pool.  When this pool is exhausted of threads, Gremlin Server will continue to accept incoming requests, but the queue will continue to grow.  If left to grow too large, the server will begin to slow.  When tuning around this setting, consider whether the bulk of the scripts being processed will be "fast" or "slow", where "fast" generally means being measured in the low hundreds of milliseconds and "slow" means anything longer than that.
** If the bulk of the scripts being processed are expected to be "fast", then a good starting point for this setting is `2*threadPoolWorker`.
** If the bulk of the scripts being processed are expected to be "slow", then a good starting point for this setting is `4*threadPoolWorker`.
* Scripts that are "slow" can really hurt Gremlin Server if they are not properly accounted for.  `ScriptEngine` evaluations are blocking operations that aren't easily interrupted, so once a "slow" script is being evaluated in the context of a `ScriptEngine` it must finish its work.  Lots of "slow" scripts will eventually consume the `gremlinPool` preventing other scripts from getting processed from the queue.
** To limit the impact of this problem consider properly setting the `scriptEvaluationTimeout` and the `serializedResponseTimeout` to something "sane".
** Test the traversals being sent to Gremlin Server and determine the maximum time they take to evaluate and iterate over results, then set these configurations accordingly.
** Note that `scriptEvaluationTimeout` does not interrupt the evaluation on timeout.  It merely allows Gremlin Server to "ignore" the result of that evaluation, which means the thread in the `gremlinPool` will still be consumed after the timeout.
** The more powerful setting is the `serializedResponseTimeout`, which will actually kill the result iteration process and prevent additional processing.  In most situations, the iteration and serialization process is the more costly step in this process as an errant script that retuns a million or more results could send Gremlin Server into a long streaming cycle.  Script evaluation on the other hand is usually very fast, occurring on the order of milliseconds, but that is entirely dependent on the contents of the script itself.

Developing a Driver
~~~~~~~~~~~~~~~~~~~

image::gremlin-server-protocol.png[width=325]

One of the roles for Gremlin Server is to provide a bridge from TinkerPop to non-JVM languages (e.g. Go, Python, etc.).  Developers can build language bindings (or driver) that provide a way to submit Gremlin scripts to Gremlin Server and get back results.  Given the exstensible nature of Gremlin Server, it is difficult to provide an authoritative guide to developing a driver.  It is however possible to describe the core communication protocal using the standard out-of-the-box configuration which should provide enough information to develop a driver for a specific language.

image::gremlin-server-flow.png[width=300,float=right] 

Gremlin Server is distributed with a configuration that utilizes link:http://en.wikipedia.org/wiki/WebSocket[WebSockets] with a custom sub-protocol.  Under this configuration, Gremlin Server accepts requests containing a Gremlin script, evaluates that script and then strems back the results.  The notion of "streaming" is depicted in the diagram to the right.  

The diagram shows an incoming request to process the Gremlin script of `g.V`.  Gremlin Server evaluates that script getting an `Iterator` of vertices as a result.  Gremlin Server recognizes that the `Iterator` and steps through each `Vertex` within it.  The vertices are batched together given the `resultIterationBatchSize` configuration.  In this case, that value must be `2` given that each "response" contains two vertices.  Each response is serialized given the requested serializer type (JSON is likely best for non-JVM languages) and written back to the requesting client immediately.  Gremlin Server does not wait for the entire result to be iterated, before sending back a response.  It will send the responses as they are realized.

This approach allows for the processing of large result sets without having to serialize the entire result into memory for the response.  It places a bit of a burden on the developer of the driver however, because it becomes necessary to provide a way to reconstruct the entire result on the client side from all of the individual responses that Gremlin Server returns for a single request.  Again, this description of Gremlin Server's "flow" is related to the out-of-the-box configuration.  It is quite possible to construct other flows, that might be more amenable to a particular language or style of processing.

To formulate a request to Gremlin Server, a `RequestMessage` needs to be constructed.  The `RequestMessage` is a generalized representation of a request that carries a set of "standard" values in addition to optional ones that are dependent on the operation being performed.  A `RequestMessage` has these fields:

[width="100%",cols="3,10",options="header"]
|=========================================================
|Key |Description
|requestId |A link:http://en.wikipedia.org/wiki/Globally_unique_identifier[UUID] representing the unique identification for the request.
|op |The name of the "operation" to execute based on the available `OpProcessor` configured in the Gremlin Server.  To evaluate a script, use `eval`.
|processor |The name of the `OpProcessor` to utilize. The default `OpProcessor` for evaluating scripts is unamed and therefore script evaluation purposes, this value can be an empty string.
|args |A `Map` of arbitrary parameters to pass to Gremlin Server.  The requirements for the contents of this `Map` are dependent on the `op` selected.
|=========================================================

This message can be serialized in any fashion that is supported by Gremlin Server.  New serialization methods can be plugged in by implementing a `ServiceLoader` enabled `MessageSerializer`, however Gremlin Server provides for JSON serialization by default which will be good enough for purposes of most developers building drivers. A `RequestMessage` to evaluate a script with variable bindings looks like this in JSON:

[source,js]
----
{ "requestId":"1d6d02bd-8e56-421d-9438-3bd6d0079ff1",
  "op":"eval",
  "processor":"",
  "args":{"gremlin":"g.V(x).out()",
          "bindings":{"x":1},
          "language":"gremlin-groovy"}}
----

The above JSON represents the "body" of the request to send to Gremlin Server. When sending this "body" over websockets Gremlin Server can accept a packet frame using a "text" (1) or a "binary" (2) opcode. Using "text" is a bit more limited in that Gremlin Server will always process the body of that request as JSON.  Generally speaking "text" is just for testing purposes.

The preferred method for sending requests to Gremlin Server is to use the "binary" opcode.  In this case, a "header" will need be sent in addition to to the "body".  The "header" basically consists of a "mime type" so that Gremlin Server knows how to deserialize the `RequestMessage`. So, the actual byte array sent to Gremlin Server would be formatted as follows:

image::gremlin-server-request.png[]

The first byte represents the length of the "mime type" string value that follows.  Given the default configuration of Gremlin Server, this value should be set to `application/json`.  The "payload" represents the JSON message above encoded as bytes.

NOTE: Gremlin Server will only accept masked packets as it pertains to websocket packet header construction.

When Gremlin Server receives that request, it will decode it given the "mime type", pass it to the requested `OpProcessor` which will execute the `op` defined in the message.  In this case, it will evaluate the script `g.V(x).out()` using the `bindings` supplied in the `args` and stream back the results in a series of `ResponseMessages`.  A `ResponseMessage` looks like this:

[width="100%",cols="3,10",options="header"]
|=========================================================
|Key |Description
|requestId |The identifier of the `RequestMessage` that generated this `ResponseMessage`.
|status | The `status` contains a `Map` of three keys: `code` which refers to a `ResultCode` that is somewhat analogous to an link:http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html[HTTP status code], `attributes` that represent a `Map` of protocol-level information, and `message` which is just a human-readable `String` usually associated with errors.
|result | The `result` contains a `Map` of two keys: `data` which refers to the actual data returned from the server (the type of data is determined by the operation requested) and `meta` which is a `Map` of meta-data related to the response.
|========================================================= 

In this case the `ResponseMessage` returned to the client would look something like this:

[source,js]
----
{"result":{"data":[{"id":2,"label":"vertex","type":"vertex","properties":{"name":"vadas","age":27}}],
           "meta":{}},
 "requestId":"1d6d02bd-8e56-421d-9438-3bd6d0079ff1",
 "status":{"code":200,"attributes":{},"message":""}}
----

Gremlin Server is capable of streaming results such that additional responses will arrive over the WebSocket until the iteration of the result on the server is complete.  Each successful incremental message will have a `ResultCode` of 200. The response stream is always marked as "complete" by a terminating message.  The "terminator" will look like this:

[source,js]
{"result":{"data":null,
           "meta":{}},
 "requestId":"1d6d02bd-8e56-421d-9438-3bd6d0079ff1",
 "status":{"code":299,"attributes":{},"message":""}}

The `299` code signifies stream termination which means that all processing for the request `1d6d02bd-8e56-421d-9438-3bd6d0079ff1` is complete.  Please see the link:http://www.tinkerpop.com/javadocs/current/com/tinkerpop/gremlin/driver/message/ResultCode.html[javadoc] for more information on the various `code` values that are available.

OpProcessors Arguments
^^^^^^^^^^^^^^^^^^^^^^

The following sections define a non-exhaustive list of available operations and arguments for embedded `OpProcessors` (i.e. ones packaged with Gremlin Server).

Common
++++++

All `OpProcessor` instances support these arguments.

[width="100%",cols="2,2,9",options="header"]
|=========================================================
|Key |Type |Description
|batchSize |Int |When the result is an iterator this value defines the number of iterations each `ResponseMessage` should contain - overrides the `resultIterationBatchSize` server setting.
|=========================================================

Standard OpProcessor
++++++++++++++++++++

The "standard" `OpProcessor` handles requests for the primary function of Gremlin Server - executing Gremlin. Requests made to this `OpProcessor` are "sessionless" in the sense that a request must encapsulate the entirety of a transaction.  There is no state maintained between requests.  A transaction is started when the script is first evaluated and is committed when the script completes (or rolled back if an error occurred).

[width="100%",cols="3,10a",options="header"]
|=========================================================
|Key |Description
|processor |As this is the default `OpProcessor` this value can be set to an empty string
|op |[width="100%",cols="3,10",options="header"]
!=========================================================
!Key !Description
!`eval` !evaluate a Gremlin script provided as a `String`
!=========================================================
|=========================================================

'`eval` operation arguments'
[width="100%",cols="2,2,9",options="header"]
|=========================================================
|Key |Type |Description
|gremlin |String | *Required* The Gremlin script to evaluate
|bindings |Map |A set of key/value pairs to apply as variables in the context of the Gremlin script
|language |String |The flavor used (e.g. `gremlin-groovy`)
|=========================================================

Session OpProcessor
+++++++++++++++++++

The "session" `OpProcessor` handles requests for the primary function of Gremlin Server - executing Gremlin. It is like the "standard" `OpProcessor`, but instead maintains state between sessions and leaves all transaction management up to the calling client.  It is important that clients that open sessions, commit or roll them back, however Gremlin Server will try to clean up such things when a session is killed that has been abandoned.  It is important to consider that a session can only be maintained with a single machine.  In the event that multiple Gremlin Server are deployed, session state is not shared among them.

[width="100%",cols="3,10a",options="header"]
|=========================================================
|Key |Description
|processor |This value should be set to `session`
|op |
[cols="3,10",options="header"]
!=========================================================
!Key !Description
!`eval` !evaluate a Gremlin script
!=========================================================
|=========================================================

'`eval` operation arguments'
[width="100%",options="header"]
|=========================================================
|Key |Type |Description
|gremlin |String | *Required* The Gremlin script to evaluate
|session |String | *Required* The session identifier for the current session - typically this value should be a UUID (the session will be created if it doesn't exist)
|bindings |Map |A set of key/value pairs to apply as variables in the context of the Gremlin script
|language |String |The flavor used (e.g. `gremlin-groovy`)
|=========================================================

[[gremlin-plugins]]
Gremlin Plugins
---------------

image:gremlin-plugin.png[width=125]

Plugins provide a way to expand the features of Gremlin Console and Gremlin Server. The first step to developing a plugin is to implement the `GremlinPlugin` interface:

[source,java]
----
include::{basedir}/gremlin-groovy/src/main/java/com/tinkerpop/gremlin/groovy/plugin/GremlinPlugin.java[]
----

The most simple plugin and the one most commonly implemented will likely be one that just provides a list of classes to import to the Gremlin Console.  This type of plugin is the easiest way for implementers of the TinkerPop Structure and Process APIs to make their implementations available to users.  The Neo4j implementation currently maintained by TinkerPop has just such a plugin:

[source,java]
----
include::{basedir}/neo4j-gremlin/src/main/java/com/tinkerpop/gremlin/neo4j/groovy/plugin/Neo4jGremlinPlugin.java[]
----

Note that the plugin provides a unique name for the plugin which follows a namespaced pattern as _namespace_._plugin-name_ (e.g. "tinkerpop.hadoop" - "tinkerpop" is the reserved namespace for TinkerPop maintained plugins). To make Neo4j classes available to the Console, the `PluginAcceptor` is given a `Set` of imports to provide to the plugin host.  The `PluginAcceptor` essentially behaves as an abstraction to the "host" that is handling the `GremlinPlugin`.  `GremlinPlugin` implementations maybe hosted by the Console as well as the `ScriptEngine` in Gremlin Server.  Obviously, registering new commands and other operations that are specific to the Groovy Shell don't make sense there.  Write the code for the plugin defensively by checking the `GremlinPlugin.env` key in the `PluginAcceptor.environment()` to understand which environment the plugin is being used in.

There is one other step to follow to ensure that the `GremlinPlugin` is visible to its hosts.  `GremlinPlugin` implementations are loaded via link:http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[ServiceLoader] and therefore need a resource file added to the jar file where the plugin exists.  Add a file called `com.tinkerpop.gremlin.groovy.plugin.GremlinPlugin` to `META-INF.services`.  In the case of the Neo4j plugin above, that file will have this line in it:

[source,java]
----
include::{basedir}/neo4j-gremlin/src/main/resources/META-INF/services/com.tinkerpop.gremlin.groovy.plugin.GremlinPlugin[]
----

Once the plugin is packaged, there are two ways to test it out:

. Copy the jar and its dependencies to the Gremlin Console path and start it.
. Start Gremlin Console and try the `:install` command.  For the case of the Neo4j plugin, it would look like this: `:install com.tinkerpop neo4j-gremlin x.y.z`.

In either case, once one of these two approaches is taken, the jars and their dependencies are available to the Console.  The next step is to "activate" the plugin by doing `:plugin use neo4j`, where "neo4j" refers to the name of the plugin to activate.

NOTE: When `:install` is used logging dependencies related to link:http://www.slf4j.org/[SLF4J] are filtered out so as not to introduce multiple logger bindings (which generates warning messages to the logs).

A plugin can do much more than just import classes.  One can expand the Gremlin language with new functions or steps, provide useful commands to make repetitive or complex tasks easier to execute, or do helpful integrations with other systems.  The secret to doing so lies in the `PluginAcceptor`.  As mentioned earlier, the `PluginAcceptor` provides access to the host of the plugin.  It provides several important methods for doing so:

. `addBinding` - These two function allow the plugin to inject whatever context it wants to the host.  For example, doing `addBinding('x',1)` would place a variable of `x` with a value of 1 into the console at the time of the plugin load.
. `eval` - Evaluates a script in the context of the host at the time of plugin startup.  For example, doing `eval("sum={x,y->x+y}")` would create a `sum` function that would be available to the user of the Console after the load of the plugin.
. `environment` - Provides context from the host environment.  For the console, the environment will return a `Map` containing a reference to the `IO` stream and the `Groovysh` instance.  These classes represent very low-level access to the underpinnings of the console.  Access to `Groovysh` allows for advanced features such as registering new commands (e.g. like the `:plugin` or `:remote` commands).

Plugins can also tie into the `:remote` and `:submit` commands.  Recall that a `:remote` represents a different context within which Gremlin is executed, when issued with `:submit`.  It is encouraged to use this integration point when possible, as opposed to registering new commands that can otherwise follow the `:remote` and `:submit` pattern.  To expose this integration point as part of a plugin, implement the `RemoteAcceptor` interface:

TIP: Be good to the users of plugins and prevent dependency conflicts. Maintaining a conflict free plugin is most easily done by using the link:http://maven.apache.org/enforcer/maven-enforcer-plugin/[Maven Enforcer Plugin].

TIP: Consider binding the plugin's minor version to the TinkerPop minor version so that it's easy for users to figure out plugin compatibility.  Otherwise, clearly document a compatibility matrix for the plugin somewhere that users can find it.

[source,java]
----
include::{basedir}/gremlin-groovy/src/main/java/com/tinkerpop/gremlin/groovy/plugin/RemoteAcceptor.java[]
----

The `RemoteAcceptor` implementation ties to a `GremlinPlugin` and will only be executed when in use with the Gremlin Console plugin host.  Simply instantiate and return a `RemoteAcceptor` in the `GremlinPlugin.remoteAcceptor()` method of the plugin implementation.  Generally speaking, each call to `remoteAcceptor()` should produce a new instance of a `RemoteAcceptor`.  It will likely be necessary that you provide context from the `GremlinPlugin` to the `RemoteAcceptor` plugin.  For example, the `RemoteAcceptor` implementation might require an instance of `Groovysh` to provide a way to dynamically evaluate a script provided to it so that it can process the results in a different way.

[[gephi-plugin]]
Gephi Plugin
~~~~~~~~~~~~

image:gephi-logo.png[width=200, float=left] link:http://gephi.github.io/[Gephi] is an interactive visualization, exploration, and analysis platform for graphs. The link:https://marketplace.gephi.org/plugin/graph-streaming/[Graph Streaming] plugin for Gephi provides an link:https://wiki.gephi.org/index.php/Graph_Streaming[API] that can be leveraged to stream graphs and visualize traversals interactively through the Gremlin Gephi Plugin.

The following instructions assume that Gephi has been download and installed.  It further assumes that the Graph Streaming plugin has been installed (`Tools > Plugins`). The following instructions explain how to visualize a `Graph` and `Traversal`.

In Gephi, create a new project with `File > New Project`.  In the lower left view, click the "Streaming" tab, open the Master drop down, and right click `Master Server > Start` which starts the Graph Streaming server in Gephi and by default accepts requests at `http://localhost:8080/workspace0`:

image::gephi-start-server.png[width=800]

Start the xref:gremlin-console[Gremlin Console] and activate the Gephi plugin:

[source,groovy]
gremlin> :plugin use tinkerpop.gephi
==>tinkerpop.gephi activated
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> :remote connect tinkerpop.gephi
==>Connection to Gephi - http://localhost:8080/workspace0 with stepDelay:1000, startRGBColor:[0.0, 1.0, 0.5], colorToFade:g, colorFadeRate:0.7
gremlin> :> g
==>tinkergraph[vertices:6 edges:6]

The above Gremlin session activates the Gephi plugin, creates the "modern" `TinkerGraph`, uses the `:remote` command to setup a connection to the Graph Streaming server in Gephi (with default parameters that will be explained below), and then uses `:submit` which sends the vertices and edges of the graph to the Gephi Streaming Server. The resulting graph appears in Gephi as displayed in the left image below.

image::gephi-graph-submit.png[width=800]

Now that the graph is visualized in Gephi, it is possible to link:https://gephi.github.io/users/tutorial-layouts/[apply a layout algorithm], change the size and/or color of vertices and edges, and display labels/properties of interest.  Further information can be found in Gephi's tutorial on link:https://gephi.github.io/users/tutorial-visualization/[Visualization].  After applying the Fruchterman Reingold layout, increasing the node size, decreasing the edge scale, and displaying the id, name, and weight attributes the graph looks as displayed in the right image above.

NOTE: It's recommended to choose a continuously running layout algorithm like Fruchterman Reingold or Force Atlas, because every update to color the visited vertices causes their positions to be reset, so these layouts will constantly adjust to account for these changes and make visualization of the traversals.  This also explains why the graph seems to rotate each store step in the screenshots below.

Consider the following traversal:

[source,groovy]
g.V(2).in().out('knows').
      has('age',gt,30).outE('created').
      has('weight',gt,0.5f).inV()

To visualize it insert the appropriately named `store('n')` steps where `n` is an integer, and the vertices will be highlighted in ascending store step order.

[source,groovy]
gremlin> g.V(2).in('knows').out('knows').has('age',gt,30).
               outE('created').has('weight',gt,0.5f).inV().values('name')
==>ripple
gremlin> traversal = g.V(2).store('1').
                           in('knows').store('2').
                           out('knows').has('age',gt,30).store('3').
                           outE('created').has('weight',gt,0.5f).inV().store('4')
==>{v[5]=1}
gremlin> traversal.sideEffects().get('1')
==>v[2]
gremlin> traversal.sideEffects().get('2')
==>v[1]
gremlin> traversal.sideEffects().get('3')
==>v[4]
gremlin> traversal.sideEffects().get('4')
==>v[5]
gremlin> 
gremlin> :> traversal
Visualizing vertices at step: 1... visited: 1
Visualizing vertices at step: 2... visited: 1
Visualizing vertices at step: 3... visited: 1
Visualizing vertices at step: 4... visited: 1
gremlin>

When `:> traversal` is called, it iterates through the sideEffects of the traversal accessing the vertices stored at each corresponding step. It then updates the vertices' color with `startRGBColor`, which in this case is a lime-green blue: [0.0,1.0,0.5]. After the first step visualization, it sleeps for the configured `stepDelay` in milliseconds. On the second step, it decays the configured `colorToFade` of all the previously visited vertices in prior steps, by multiplying the current `colorToFade` value for each vertex with the `colorFadeRate`.  To avoid color decay on prior steps, then provide a `colorFadeRate` value of `1.0`.  The screenshots below show how the visualization evolves over the 4 steps:

image::gephi-traversal.png[width=1200]

Once a traversal visualization has executed, clear the colors in Gephi by selecting the grey square icon under the magnifying glass icon on the lower left tool bar next to the graph canvas.  Run another traversal against the same graph and it will update the appropriate vertices.  To get a sense of how the visualization configuration parameters affect the output, see the example below:

[source,groovy]
gremlin> :remote config startRGBColor [0.0,0.3,1.0]
==>Connection to Gephi - http://localhost:8080/workspace0 with stepDelay:1000, startRGBColor:[0.0, 0.3, 1.0], colorToFade:g, colorFadeRate:0.7
gremlin> :remote config colorToFade b
==>Connection to Gephi - http://localhost:8080/workspace0 with stepDelay:1000, startRGBColor:[0.0, 0.3, 1.0], colorToFade:b, colorFadeRate:0.7
gremlin> :remote config colorFadeRate 0.5
==>Connection to Gephi - http://localhost:8080/workspace0 with stepDelay:1000, startRGBColor:[0.0, 0.3, 1.0], colorToFade:b, colorFadeRate:0.5
gremlin> :> traversal
Visualizing vertices at step: 1... visited: 1
Visualizing vertices at step: 2... visited: 1
Visualizing vertices at step: 3... visited: 1
Visualizing vertices at step: 4... visited: 1
gremlin>

image::gephi-traversal-config.png[width=400]

The visualization configuration above starts with a blue color now (most recently visited), fading the blue color (so that dark green remains on oldest visited), and fading the blue color more quickly so that the gradient from dark green to blue across steps has higher contrast. Here is a more detailed description of Gephi plugin configuration parameters, in the order accepted on the `:remote connect gephi` command, or modified via the `:remote config` command:

[width="100%",cols="3,10,^2",options="header"]
|=========================================================
|Parameter |Description |Default
|workspace |The name of the workspace that your Graph Streaming server is started for. |workspace0
|host |The host URL where the Graph Streaming server is configured for. |localhost
|port |The port number of the URL that the Graph Streaming server is listening on. |8080
|stepDelay |The amount of time in milliseconds to pause between step visualizations. |1000
|startRGBColor |A size 3 float array of RGB color values which define the starting color to update most recently visited nodes with.  |[0.0,1.0,0.5]
|colorToFade |A single char from the set `{r,g,b,R,G,B}` determining which color to fade for vertices visited in prior steps |g
|colorFadeRate |A float value in the range `(0.0,1.0]` which is multiplied against the current `colorToFade` value for prior vertices; a `1.0` value effectively turns off the color fading of prior step visited vertices |0.7
|=========================================================

[[server-plugin]]
Server Plugin
~~~~~~~~~~~~~

image:gremlin-server.png[width=200,float=left] xref:gremlin-server[Gremlin Server] remotely executes Gremlin scripts that are submitted to it.  The Server Plugin provides a way to submit scripts to Gremlin Server for remote processing.  Read more about the plugin and how it works in the Gremlin Server section on xref:connecting-via-console[Connecting via Console]. 

NOTE: The Server Plugin is enabled in the Gremlin Console by default.

[[sugar-plugin]]
Sugar Plugin
~~~~~~~~~~~~

image:gremlin-sugar.png[width=120,float=left] In previous versions of Gremlin-Groovy, there were numerous link:http://en.wikipedia.org/wiki/Syntactic_sugar[syntactic sugars] that users could rely on to make their traversals more succinct. Unfortunately, many of these conventions made use of link:http://docs.oracle.com/javase/tutorial/reflect/[Java reflection] and thus, were not performant. In TinkerPop3, these conveniences have been removed in support of the standard Gremlin-Groovy syntax being both inline with Gremlin-Java8 syntax as well as always being the most performant representation. However, for those users that would like to use the previous syntactic sugars (as well as new ones), there is `SugarGremlinPlugin`.

IMPORTANT: It is important that the sugar plugin is loaded in a Gremlin Console session prior to any manipulations of the respective TinkerPop3 objects as Groovy will cache unavailable methods and properties.

[source,groovy]
gremlin> :plugin use tinkerpop.sugar
==>tinkerpop.sugar activated
gremlin> g.V(1).values('name')  // conventional
==>marko
gremlin> g.V(1).name  // sugar
==>marko
gremlin> g.V().map{it.get().value('name')}  // conventional
==>marko
==>vadas
==>lop
==>josh
==>ripple
==>peter
gremlin> g.V.map{it.name}  // sugar
==>marko
==>vadas
==>lop
==>josh
==>ripple
==>peter

The examples above are generalized below:

. Missing element fields: if a vertex or edge's instance field is selected and that field does not exist, then it is assumed the user means `values('fieldName')`.
. Missing traverser method: if a traverser method is called and that method doesn't exist, then it is assumed that the method is on the wrapped object of the traverser.
. Missing traverser field: if a traverser field is called and that field doesn't exist, then it is assumed that the field is on the wrapped object of the traverser.
. Missing traversal field: if a traversal field is called and that field doesn't exist, then it is assumed either a step() or defaults to `values('step')`.

[[utilities-plugin]]
Utilities Plugin
~~~~~~~~~~~~~~~~

The Utilities Plugin provides various functions, helper methods and imports of external classes that are useful in the console.  

NOTE: The Utilities Plugin is enabled in the Gremlin Console by default.

[[clock]]
Clock
^^^^^

The `clock` function provides a simple way to time how long it takes to execute a traversal (or any other code within the closure passed to it). By default, the `clock` function will execute the contents of the closure one hundred times and calculate the average time taken per execution.  `clock` can take an optional integer parameter to override number of times to execute the closure contents.

[source,groovy]
----
gremlin> :plugin use tinkerpop.utilities
==>tinkerpop.utilities activated
gremlin> g = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> clock{g.V().both().both().both().iterate()}
==>0.6182899999999999
gremlin> clock(1000){g.V().both().both().both().iterate()}
==>0.23745999999999978
----

[[benchmarking-and-profiling]]
Benchmarking and Profiling
^^^^^^^^^^^^^^^^^^^^^^^^^^

The link:https://code.google.com/p/gperfutils/[GPerfUtils] library provides a number of performance utilities for Groovy.  Specifically, these tools cover benchmarking and profiling.  

Benchmarking allows execution time comparisons of different pieces of code. While such a feature is generally useful, in the context of Gremlin, benchmarking can help compare traversal performance times to determine the optimal approach.  Profiling helps determine the parts of a program which are taking the most execution time, yielding low-level insight into the code being examined. 

[source,groovy]
----
gremlin> :plugin use tinkerpop.sugar // activate sugar plugin for use in benchmark
==>tinkerpop.sugar activated
gremlin> benchmark{ 
gremlin>   'sugar' {g.V(1).name.next()}
gremlin>   'nosugar' {g.V(1).values('name').next()}}.prettyPrint()
Environment
===========
* Groovy: 2.3.6
* JVM: Java HotSpot(TM) 64-Bit Server VM (25.5-b02, Oracle Corporation)
    * JRE: 1.8.0_05
    * Total Memory: 161 MB
    * Maximum Memory: 1774.5 MB
* OS: Linux (3.13.0-32-generic, amd64)

Options
=======
* Warm Up: Auto (- 60 sec)
* CPU Time Measurement: On

         user  system   cpu  real

sugar    4135       0  4135  4143
nosugar  1223       0  1223  1226
==>null
gremlin> profile { g.V().iterate() }.prettyPrint()
Flat:

 %    cumulative   self            self     total    self    total   self    total                                                                              
time   seconds    seconds  calls  ms/call  ms/call  min ms  min ms  max ms  max ms  name                                                                        
61.8        0.02     0.02      1    22.60    22.60   22.60   22.60   22.60   22.60  com.tinkerpop.gremlin.tinkergraph.process.graph.TinkerGraphTraversal.iterate
23.5        0.03     0.00      1     8.62     8.62    8.62    8.62    8.62    8.62  com.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph.V                   
13.4        0.03     0.00      1     4.93    36.57    4.93   36.57    4.93   36.57  groovysh_evaluate$_run_closure1.doCall                                      
 1.0        0.03     0.00      1     0.38     0.40    0.38    0.40    0.38    0.40  com.tinkerpop.gremlin.groovy.loaders.GremlinLoader.isStep                   
 0.0        0.03     0.00      1     0.01     0.01    0.01    0.01    0.01    0.01  java.util.HashSet.contains                                                  

Call graph:

index  % time  self  children  calls  name                                                                                
               0.00      0.03    1/1      <spontaneous>                                                                   
[1]     100.0  0.00      0.03      1  groovysh_evaluate$_run_closure1.doCall [1]                                          
               0.02      0.00    1/1      com.tinkerpop.gremlin.tinkergraph.process.graph.TinkerGraphTraversal.iterate [2]
               0.00      0.00    1/1      com.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph.V [3]                   
               0.00      0.00    1/1      com.tinkerpop.gremlin.groovy.loaders.GremlinLoader.isStep [4]                   
--------------------------------------------------------------------------------------------------------------------------
               0.02      0.00    1/1      groovysh_evaluate$_run_closure1.doCall [1]                                      
[2]      61.8  0.02      0.00      1  com.tinkerpop.gremlin.tinkergraph.process.graph.TinkerGraphTraversal.iterate [2]    
--------------------------------------------------------------------------------------------------------------------------
               0.00      0.00    1/1      groovysh_evaluate$_run_closure1.doCall [1]                                      
[3]      23.5  0.00      0.00      1  com.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph.V [3]                       
--------------------------------------------------------------------------------------------------------------------------
               0.00      0.00    1/1      groovysh_evaluate$_run_closure1.doCall [1]                                      
[4]       1.1  0.00      0.00      1  com.tinkerpop.gremlin.groovy.loaders.GremlinLoader.isStep [4]                       
               0.00      0.00    1/1      java.util.HashSet.contains [5]                                                  
--------------------------------------------------------------------------------------------------------------------------
               0.00      0.00    1/1      com.tinkerpop.gremlin.groovy.loaders.GremlinLoader.isStep [4]                   
[5]       0.0  0.00      0.00      1  java.util.HashSet.contains [5]                                                      
--------------------------------------------------------------------------------------------------------------------------
==>null
----

[[describe-graph]]
Describe Graph
^^^^^^^^^^^^^^

A good implementation of the Gremlin APIs will validate their features against the xref:validating-with-gremlin-test[Gremlin test suite].  To learn more about a specific implementation's compliance with the test suite, use the `describeGraph` function.  The following shows the output for `HadoopGraph`:

[source,groovy]
----
gremlin> describeGraph(HadoopGraph)
==>
IMPLEMENTATION - com.tinkerpop.gremlin.hadoop.structure.HadoopGraph
TINKERPOP TEST SUITE
- Compliant with (4 of 8 suites)
> com.tinkerpop.gremlin.process.ProcessStandardSuite
> com.tinkerpop.gremlin.process.ProcessComputerSuite
> com.tinkerpop.gremlin.process.GroovyProcessStandardSuite
> com.tinkerpop.gremlin.process.GroovyProcessComputerSuite
- Opts out of 12 individual tests
> com.tinkerpop.gremlin.process.graph.step.map.MatchTest$StandardTest#g_V_matchXa_hasXname_GarciaX__a_0writtenBy_b__a_0sungBy_bX
	"Hadoop-Gremlin is OLAP-oriented and for OLTP operations, linear-scan joins are required. This particular tests takes many minutes to execute."
...
> com.tinkerpop.gremlin.process.graph.step.map.MatchTest$JavaMatchTest#g_V_matchXa_inXsungByX_b__a_inXsungByX_c__b_outXwrittenByX_d__c_outXwrittenByX_e__d_hasXname_George_HarisonX__e_hasXname_Bob_MarleyXX
	"Hadoop-Gremlin is OLAP-oriented and for OLTP operations, linear-scan joins are required. This particular tests takes many minutes to execute."

- NOTE -
The describeGraph() function shows information about a Graph implementation.
It uses information found in Java Annotations on the implementation itself to
determine this output and does not assess the actual code of the test cases of
the implementation itself.  Compliant implementations will faithfully and
honestly supply these Annotations to provide the most accurate depiction of
their support.
----
